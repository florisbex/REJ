\section{The Logical Framework}
\label{sect:formalframework}

In the previous section we developed a list of critical questions and argument schemes by analyzing transcripts of discussions about the development of an information system. The resulting list is shown in table~\ref{table:argument-schemes}. We also discussed various examples of applications of the different critical questions and all four different effects (right column of table~\ref{table:argument-schemes}): INTRO, DISABLE, REPLACE, and ATTACK.

The examples and corresponding visualizations of the previous section provided some insight into how to formalize argument schemes, critical questions, and their relationship with goal models. However, if we are to implement our framework into a tool, we require a more precise formalisation of these concepts. We choose to use formal logic to specify this, because argumentation has been studied in formal logic extensively for the past decades.

In the first subsection we develop a formal language to specify a GRL model. This language consists of propositions only, and a GRL model specified in this language can be specified as a logic program directly. In the second subsection we then provide formal definitions of all argument schemes. An instantiation of an argument scheme consists of a set of statement about a GRL model. In the third subsection we formalize the critical questions as algorithms.

\subsection{Formal Language for RationalGRL}

Basic concepts set theory are adequate to define the entities in a GRL model and the relations between them. We begin with the representation for the elements.

\begin{definition}[RationalGRL elements]
Each element of a goal model is identified with a non-negative integer. Formally: let $Actors\cup IEs \cup Links \subseteq \mathbb{N}$ denote the set of elements of a goal model, where 
\begin{itemize}
\item $Actors$ is the set of actors, 
\item $IEs$ is the set of intentional elements (softgoals, goals, tasks, and resources),
\item $Links$ is the set of links (decomposition, contribution, and dependency). 
\end{itemize}

The three sets are pairwise disjoint, i.e. $Actors \cap IEs = Actors \cap Links = IEs \cap Links = \emptyset$. 
\end{definition}

\rationale{} We identify GRL element with an identifier and not with a name, because it is possible that the name of the element changes, for instance by applying critical question CQ12a (clarification), see the example ``Clarify task \emph{Road pattern}'' above. The GRL model of figure~\ref{fig:examples:decomposition} can be formalized as follows: 
\begin{align*}
&Actors = \{1\},\\
&IEs = \{2, 3, 4\},\\ 
&Links = \{5\}.
\end{align*}

\begin{definition}[GRL intentional element type]
For an intentional element $i\in IEs$, if $i$ is a softgoal, goal, task, or resource, then this is respectively denoted by $softgoal(i), goal(i), task(i)$, and $resource(i)$.
\end{definition}

\rationale{} All intentional elements are collected in the set $IEs$. In order to distinguish softgoals, goals, tasks, and resources, we use the corresponding propositions. In our example this looks as follows:
\begin{align*}
&goal(2),\\
&task(3),\\
&task(4).
\end{align*}

Note we do not require such propositions for actors, since there is only one type of actor, and all actors are contained in the set $Actors$.

\begin{definition}[Links]
Given a link $i\in Links$, we denote the links types as follows:
\begin{itemize}
\item $contrib(i,src,dest,type)$ is a contribution from $src\in IEs$ to $dest\in IEs$, where $type\in\{+,-\}$ means a positive resp. negative contribution. 
\item $decomp(i,src,\{dest_1,\ldots,dest_n\},type)$ is a decomposition of $src\in IEs$ into $\{dest_1,\dots,dest_n\}\subseteq IEs$, where $type\in\{AND,OR,XOR\}$ means respective an AND, OR, and XOR decomposition. 
\item $dep(i,src,dest)$ is a dependency from $dest\in IEs$ to $dest\in IEs$.
\end{itemize}
\end{definition}

\rationale{} Similarly to the intentional elements, we distinguish between the different types of links between IEs using the corresponding propositions. The formalisation of the link in figure~\ref{fig:examples:decomposition} looks as follows:
\begin{align*}
&decomp(5, 2, \{3,4\}, OR)
\end{align*}

\begin{definition}[Name of IE or Actor]
The name $p$ of a element $i\in IEs\cup Actors$ is denoted by $name(i,p)$.
\end{definition}

\rationale{} We formalize the description of an actor or an intentional element with a proposition $name(i,p)$. Continuing our example of formalizing figure~\ref{fig:examples:decomposition}, we have 
\begin{align*}
&name(1,\text{system}),&\\
&name(2,\text{simulate}),&\\
&name(3,\text{static\ simulation}),&\\
&name(4, \text{dynamic simulation}).&
\end{align*}
Note the decomposition link with identifier 5 does not have a name, since decompositions are already distinguished by their type (OR, XOR, AND).

\begin{definition}[Elements of an actor]
Given an actor $i\in Actors$ and a element $j\in IEs\cup Links$, we use $has(i,j)$ to denote that element $j$ belongs to actor $j$.
\end{definition}

\rationale{} In order to denote that an intentional element or a link belongs to an actor, we use $has$ statements. This looks as follows in our example:
\begin{align*}
&has(1, 2),\\
&has(1, 3),\\
&has(1, 4),\\
&has(1, 5).
\end{align*}

\begin{definition}[Disabled GRL element]
A disabled element $i\in Actors\cup IEs$ is denoted by $disabled(i)$.
\end{definition}

\rationale{} If a GRL element corresponds to an argument that is rejected, then this argument should be disabled. For instance, the GRL model in figure~\ref{fig:examples:relevant-actor} can be formalized as follows:
\begin{align*}
&Actors = \{1\},\\
&name(1, \text{development team}),\\
&disabled(1)
\end{align*}

This concludes our definitions to formalize a GRL model. An advantage of our approach is that we can formalize a GRL model using a set of facts, which can be directly be formalized as a logic program. We will come back to this in the last part of this section.

\subsection{Formal argumentation}

In the next section, we formalize an argument as a set of statements about a GRL model in the language we introduced in the previous section. First, we formalize an argumentation framework and its semantics, which is used to determine sets of acceptable arguments.

\begin{definition}[Argumentation framework]
An argumentation framework $AF=(Args,Att)$ consists of a set of arguments $Args$ and an attack relationship $Att:Args\times Args$, where $(A_1,A_2)\in Att$ means that argument $A_1\in Args$ attacks arguments $A_2\in Args$.
\end{definition}

\rationale{} This is the standard definition used by Dung~\cite{Dung1995}. For instance, the argumentation framework from figure~\ref{fig:pras:example} can be formalized as:
\begin{align*}
&Args=\{A_1,A_2,A_3\}\\
&Att = \{(A_2,A_1),(A_1,A_3),(A_3,A_1)\}
\end{align*}

\todo{Marc}{Marc}{explain semantics}

\subsection{Algorithms for instantiating the argument schemes}

We formalize an argument as a set of statements about a GRL model in the language we introduced in the previous section. For instance, $A= \{actor(0), name(0,student)\}$ is an argument stating that identifier 0 represent an actor, and that the name of this actor is \emph{Student}. An argument scheme then corresponds to adding one or more arguments to the set of arguments.

In the following algorithms, we assume the following global variables:
\begin{itemize}
\item $id$ the current highest identifier of the elements. This variable is increased for each new element that is added.
\item $Args$ contains the set of all arguments.
\item $Att$ contains the set of all attack relations.
\end{itemize}

\begin{algorithm}[h]
  \caption{Applying AS0: Actor $a$ is relevant}\label{alg:as0}
  \begin{algorithmic}[1]
    \Procedure{$AS_0$}{$a$}
    \State $id\gets id+1$
    \State $A \gets \{actor(id), name(id,a)\}$
    \State $Args \gets Args \cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{} Algorithm~\ref{alg:as0} takes one argument, namely the name of the actor $a$. In figure~\ref{fig:examples:relevant-actor2}, the application of the argument scheme $AS_(\text{Development team})$, results in one argument: $Args = \{\{actor(0), name(0, \text{Development team})\}\}$.

\begin{algorithm}[h]
  \caption{Applying AS1: Actor $a_{id}$ has resource $n$}\label{alg:as1}
  \begin{algorithmic}[1]
    \Procedure{$AS_1$}{$a_{id}, n$}
    \State $id\gets id+1$
    \State $A\gets \{resource(id), name(id,n), has(a_{id},id)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{}  This argument scheme takes two arguments, the identifier $a_{id}$ of the actor and the resource name $n$. 

The formalisations of argument scheme AS2 to AS4 are exactly the same as AS1 but then for respectively tasks, goals, and softgoals. Therefore, we have omitted them here. We continue with argument scheme AS5.

\begin{algorithm}[h]
  \caption{Applying AS5: Goal $g_{id}$ decomposes into tasks $T_1,\ldots,T_n$}\label{alg:as5}
  \begin{algorithmic}[1]
    \Procedure{$AS_5$}{$g_{id}, \{T_1,\ldots,T_n\}, type$}
    \State $T_{id} = \emptyset$
    \For{$T_i$ in $\{T_1,\ldots,T_n\}$}
      \If{$\exists_{A\in Args} \{task(t_{id}),name(t_{id},T_i)\}\subseteq A$}
        \State $T_{id} \gets T_{id} \cup \{t_{id}\}$
      \Else
        \State $id\gets id+1$
        \State $A \gets \{task(id),name(id,T_i)\}$
        \State $Args \gets Args\cup A$
        \State $T_{id} \gets T_{id} \cup \{id\}$
      \EndIf
    \EndFor
    \State $id\gets id+1$
    \State $A\gets \{decomp(id, g_{id}, T_{id}, type)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{} The procedure in algorithm~\ref{alg:as5} takes three arguments: $g_{id}$ is the identifier of goal $G$, $T=(T_1,\ldots,T_n)$ is a list of decomposing task names, and $type\in\{and,or,xor\}$ is the decomposition type. The for loop in the algorithm iterates over all tasks in list $T$, and if a task does not exist yet, an argument is added for it. This ensures that all tasks have corresponding arguments. Note that the algorithm assumes the goal already exists.

\begin{algorithm}[h]
  \caption{Applying AS6: Task $t_{id}$ contributes to softgoal $s$}\label{alg:as6}
  \begin{algorithmic}[1]
    \Procedure{$AS_6$}{$t_{id}, s$}
    \If{$\exists_{A\in Args} \{softgoal(i),name(i,s)\}\subseteq A$}
        \State $s_{id} \gets i$
    \Else
      \State $id\gets id+1$
      \State $A \gets \{softgoal(id),name(id,t)\}$
      \State $Args \gets Args\cup A$
      \State $s_{id} \gets id$
    \EndIf
    \State $id\gets id+1$
    \State $A\gets \{contr(id, t_{id}, s_{id}, pos)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{} The procedure in algorithm~\ref{alg:as6} takes two arguments: $t_{id}$ is the identifier of task $T$, and $s$ is the softgoal name that is contributed to. The if statements check if the softgoal exists already, and if not, an argument is added for it. This ensures that all softgoals have corresponding arguments. Note that the algorithm assumes the task already exists.

The algorithms for $AS7$ to $AS11$ all have a very similar structure as algorithm~\ref{alg:as6} and have therefore been omitted from this article.

\subsection{Algorithms for answering the critical questions}

We now develop algorithms for our critical questions. We start with the critical questions that have as effect DISABLE. All critical questions CQ0-CQ5a, CQ6a, CQ7a, CQ8, CQ11, and CQ12 fall into this category. The algorithm below applies when the critical question is answered affirmatively.

\begin{algorithm}[h]
  \caption{Applying DISABLE: Element $i$ is disabled}\label{alg:disable}
  \begin{algorithmic}[1]
    \Procedure{DISABLE}{$i$}
    \State $id\gets id+1$
    \State $A\gets \{disabled(i))\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{} We the see disable operation is quite straightforward. It simply consists of adding an argument stating argument $i$ is disabled.

Next we consider the REPLACE operation. This operation is less straightforward and cannot be captured by a single algorithm, since the operation depends on the type of argument scheme.

\begin{algorithm}[h]
  \caption{Answering CQ5b: ``Does goal $G$ decompose into any other tasks?'' With: ``Yes, namey into tasks $t_{n+1},\ldots,t_k$''}\label{alg:cq5b}
  \begin{algorithmic}[1]
    \Procedure{CQ5b}{$g_{id},\{i_1,\ldots,i_n\}, type, \{t_1,\ldots,t_k\}$}
    \State $T_{id} = \{i_1,\ldots,i_n\}$
    \For{$t_i$ in $\{t_1,\ldots,t_k\}$}\label{alg:cq5b:for1}
      \If{$\exists_{A\in Args} \{task(t_{id}),name(t_{id},t_i)\}\subseteq A$}
        \State $T_{id} \gets T_{id} \cup \{t_{id}\}$
      \Else
        \State $id\gets id+1$
        \State $A \gets \{task(id),name(id,t_i)\}$
        \State $Args \gets Args\cup A$
        \State $T_{id} \gets T_{id} \cup \{id\}$
      \EndIf
    \EndFor
    \State $id\gets id+1$
    \State $A_{new} = \{decomp(id, g_{id}, T_{id}, type)\}$\label{alg:cq5b:newarg}
    \For{$A$ in $\{decomp(d,g_{id},x,y)\}\subseteq A\mid A\in Args\}$}\label{alg:cq5b:for2}
      \State $Att\gets Att \cup \{(A_{new},A)\}$
    \EndFor
    \State $Args \gets Args \cup \{A_{new}\}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{} Algorithm~\ref{alg:cq5b} is executed when critical question CQ5b is answered, which is a critical question for argument scheme AS5. Therefore, it assumes an argument for a goal decomposition of the form $decomp(d, g_{id}, \{i_1,\ldots,i_n\},type)$ as already been generated (see algorithm~\ref{alg:as5}). The goal of the algorithm is to generate a new argument of the form $decomp(d, g_{id}, \{i_1,\ldots,i_5\}\cup \{j_1,\ldots,j_k\}, type)$, where $\{j_1,\ldots,j_k\}$ are the identifiers of the additional decomposing tasks $\{t_1,\ldots,t_k\}$. The first for loop in line~\ref{alg:cq5b:for1} check whether any of these tasks already exist, and if not, adds corresponding arguments for them. The list of all decomposing tasks is stored in $T_{id}$. The new argument for the decomposition link is then created in line~\ref{alg:cq5b:newarg}. Finally, the last for loop on line~\ref{alg:cq5b:for2} ensures that all previous arguments for decomposition links are attacked by the new argument. This ensures that only the new decomposition link will be accepted.

The REPLACE operations of CQ10a and CQ10b have a very similar structure as algorithm~\ref{alg:cq5b} and have therefore been omitted. We continue with the last REPLACE operation left, namely CQ13.

\begin{algorithm}[h]
  \caption{Answering CQ13: ``Is the name of element $i$ clear?'' With: ``No, it should be $n$''}\label{alg:cq13}
  \begin{algorithmic}[1]
    \Procedure{CQ13}{$i, n$}
    \State $id\gets id+1$
    \State $ArgsN \gets\{A\backslash\{name(i,x)\}\mid$\par\label{alg:cq13:line3}
    \hskip\algorithmicindent$A\in Args, name(i,x)\in A\}$
    \State $A \gets B \cup \{name(i,n)\}$ with $B\in ArgsN$
    \State $Args \gets Args \cup \{A\}$
    \For{$B$ in $ArgsN$}
      \State $Att\gets Att \cup \{(A,B)\}$
    \EndFor
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{} Algorithm~\ref{alg:cq13} first collects all arguments contain a statement of the form $name(i,x)$ into the set $ArgsN$, where $x$ can by any name. These are all the arguments that the new argument will attack, to ensure this is the only argument for a name of this element type. Since all such arguments are the same, except for the name proposition, we can take any such argument to construct a new one. The argument is added to the set of arguments, and the for loop ensures that all previous arguments are attacked.

We next turn to the INTRO operations, which are very similar to the algorithms for argument schemes. The main difference is that when answering a critical question, we can already assume an argument has been created, so we do not have to create it again.

\begin{algorithm}[h]
  \caption{Answering CQ6b: ``Are there alternative ways of contributing to the same softgoal $s_{id}$?'' With: ``Yes, namely by doing task $t$''}\label{alg:cq6b}
  \begin{algorithmic}[1]
    \Procedure{CQ6b}{$s_{id}, t$}
    \If{$\exists_{A\in Args} \{task(i),name(i,t)\}\subseteq A$}
        \State $t_{id} \gets i$
    \Else
      \State $id\gets id+1$
      \State $A \gets \{task(id),name(id,t)\}$
      \State $Args \gets Args\cup A$
      \State $t_{id} \gets id$
    \EndIf
    \State $id\gets id+1$
    \State $A\gets \{contr(id, t_{id}, s_{id}, pos)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\rationale{} Comparing algorithm~\ref{alg:cq6b} with algorithm~\ref{alg:as6} shows that the two algorithms are indeed very similar. 

The other critical questions with effect INTRO, namely CQ6c, CQ6d, CQ7b, and CQ9 all have a very similar structure to algorithm~\ref{alg:cq6b} and have therefore been omitted.

Our final critical question is the generic counterargument, which is very simple.

\begin{algorithm}[h]
  \caption{Generic counterargument to argument $A$}\label{alg:cq6b}
  \begin{algorithmic}[1]
    \Procedure{Attack}{$A$}
    \State $A_{new} = \{\}$
    \State $Args \gets Args \cup \{A_{new}\}$
    \State $Att \gets Att \cup \{(A_{new},A)\}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{Some examples}

\todo{Marc}{Marc}{Revisit the examples}