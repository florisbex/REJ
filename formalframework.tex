\section{RationalGRL: Logical Framework}
\label{sect:formalframework}

In Section~\ref{sect:overview}, we have shown through a language definition and informal examples from our case study that it is possible to trace elements of the goal model back to their underlying arguments (requirement 2), and that it is possible to determine the effect of changes in the underlying argumentation on the goal model, and vice versa (requirement 3). A more formal, logical rendition of this traceability will be presented in this section. Our main approach here is to use formal argumentation, which allows us to use many of the techniques developed in that area directly (see Section~\ref{sect:background:pras}).

In Section~\ref{sect:goalmodeling:logicallanguage} we present the basic logical language of our formalism, based on the metamodel from Section~\ref{sect:overview:lang}. Section~\ref{sect:goalmodeling:argumentationsemantics} then presents formal definitions of arguments and how the status of arguments can be computed, which was already briefly informally discussed in Section~\ref{sect:background:pras}. In Section~\ref{sect:algorithms} we then develop algorithms for instantiating argument schemes and for answering critical questions, formally capturing the \textsf{INTRO}, \textsf{REPLACE} and \textsf{DISABLE} operations of which examples were previously given in Section~\ref{sect:overview:examples}. Finally, in Section~\ref{sect:rationalGRL-GRL} we define the link between RationalGRL models on the one hand and GRL models -- which form a subset of the set of RationalGRL models -- on the other hand, formally capturing the export function of our tool (cf. Section~\ref{sect:tool}). 

\subsection{Logical Language for RationalGRL}
\label{sect:goalmodeling:logicallanguage}

We assume familiarity with basic notions from propositional logic and set theory. An \emph{atom} is a formula with no logical connectives ($\vee, \wedge, \rightarrow, \leftrightarrow$) or negation ($\neg$).  A \emph{ground atom} is an atom without variables.

We first define the logical language for RationalGRL. This logical language is largely based on the metamodel (Section~\ref{sect:overview:lang}).

\begin{definition}[RationalGRL Language]
The \emph{RationalGRL language} $\mathcal{L}$ contains the following atoms:
\begin{itemize}
\item $actor(i,n)$: Identifier $i$ is an actor with name $n$.
\item $IE(i,n,t,dt)$: Element with identifier $i$ is an intentional element with name $n$ of type $t$ and with decomposition-type $dt$, where: 
\begin{itemize}
\item $t$ is one of $softgoal$, $goal$, $task$, $resource$ or $belief$
\item $dt$ is one of $and$, $or$, $xor$ or $none$.
\end{itemize}
\item $EL(k,i,j,lt)$: The element link with identifier $k$ is of link-type $lt$ and links the element with identifier $i$ to the element with identifier $j$, where:
\begin{itemize}
\item $t$ is one of $decomposition$, $dependency$ or $contribution$
\end{itemize}
\item $has(i,j)$: Identifier $i$ (which is an actor) has the element corresponding to identifier $j$.
\item $arg(i,n)$: Element with identifier $i$ is a generic argument with name $n$
\item $disable(i,r)$: The element or relationships corresponding to identifier $i$ should be disabled because reason $r$.
\end{itemize}

\noindent Identifiers $i,j,k$ are natural numbers. Names $n$, types $t, dt, lt$ and reasons $r$ are strings. We assume that links and elements have unique identifiers and names. 
\end{definition}

\todo{F}{M}{Ik ben niet helemaal gelukkig met IE en EL. Ik had eerst $intentional\_element(i,n,t,dt)$ en $element\_link(k,i,j,lt)$ maar dat komt slecht uit in voorbeelden en algoritmes omdat dat lange namen zijn. Wat vind jij?}

Using the language from Definition 1, we can define GRL models.

\begin{definition}[GRL model] \label{def:rationaGRLmodel}
A \emph{GRL model} $\mathcal{M}$ is a set of ground atoms based on $\mathcal{L}$, without atoms of the form $arg(i,n)$ and $disable(i,r)$.
\end{definition}

An example of the specification of the RationalGRL model in Figure~\ref{fig:example_AS} is shown in Table~\ref{table:grl_atom_spec}, written in logic programming style. A more elaborate example of a specification is shown in Appendix~\ref{ch:grlspec}, showing a complete specification of the traffic simulator GRL model in Figure~\ref{fig:trafficsim}\todo{F}{M}{change Appendix specification to match the still-to-be-created example in section~\ref{sect:tool}}.

Notice that Definition~\ref{def:rationaGRLmodel} does not put any constraints on a RationalGRL model. If desired, constraints can be captured using simple axioms which enforce, for example, that each element link has one source and one destination element, both of which are intentional elements. For simplicity's sake, we will leave these constraints implicit in this article. 

\begin{table}[h!]
\centering
\begin{tabularx}{\columnwidth}{|X|}
\hline
\texttt{actor(0,system).}\\
\texttt{IE(1,simulate\_traffic, goal, or).}\\
\texttt{IE(2,static\_simulation, task, none).}\\
\texttt{IE(3,dynamic\_simulation, task, none).}\\
\texttt{has(0,1).}\\ 
\texttt{has(0,2).}\\ 
\texttt{has(0,3).}\\
\texttt{EL(4,2,1,decomposition).}\\
\texttt{EL(5,3,1,decomposition).}\\

\hline
\end{tabularx}
\caption{Specification of the RationalGRL model in Figure~\ref{fig:example_AS}}
\label{table:grl_atom_spec}
\end{table}

\subsection{Formal argumentation}
\label{sect:goalmodeling:argumentationsemantics}

In the previous subsection we introduced a language to specify a RationalGRL model. In this subsection we give a formal definition of an argument.

\begin{definition}[Argument] \label{def:argument}
An \emph{argument} $A\subseteq Args$ is a set of ground atoms based on $\mathcal{L}$.
\end{definition}

This simple definition allows us to form arguments about (parts of) a RationalGRL model. For instance, $A_1$: $\{actor(0,system)\}$ is an argument stating that there is an actor \emph{system}, $A_2$: $IE(1,goal,simulate\_traffic,none)$ is an argument stating that there is a goal \emph{simulate\_traffic}, $A_3$: $\{has(0,1)\}$ is an argument stating that the actor with id $0$ (in this case \emph{system}) has has goal \emph{simulate\_traffic}, and $A_4 = A_1 \cup A_2 \cup A_3$ is one argument for the fact that actor \emph{system} has goal \emph{simulate\_traffic}. 

Note that, like a RationalGRL model, an argument is a set of atoms from our language. This makes sense: as the metamodel (Figure~\ref{fig:metamodel}) shows, a RationalGRL model is comprised of arguments, that is, it is the union of all arguments. Furthermore, similar to Definition~\ref{def:rationaGRLmodel} for RationalGRL models, Definition~\ref{def:argument} does not put any restrictions on the content of an argument, which makes it possible to form arguments that do not correspond to correct or sensible RationalGRL models. For example, argument $A_3$ from the above example only makes sense if there is an actor with id $0$ and an intentional element with id $1$. While we could have chosen to put logical constraints on the content of an argument, we choose not to do so here. Instead, we put these restrictions on the algorithms in section~\ref{sect:algorithms}. The algorithms are constructed in such a way that they only allow the construction of arguments that correspond to valid RationalGRL models. The advantage of this approach is that it keeps the presentation of the formal part relatively simple.

In line with the main approaches in formal argumentation, we next introduce an argumentation framework as a set of arguments and an attack relation between the arguments.

\begin{definition}[Argumentation framework~\cite{Dung1995}] \label{def:argumentationframework}
An argumentation framework $AF=(Args,Att)$ consists of a set of arguments $Args$ and an attack relationship $Att:Args\times Args$, where $(A_1,A_2)\in Att$ means that argument $A_1\in Args$ attacks arguments $A_2\in Args$.
\end{definition}

In order to determine which arguments are accepted or not, we define \emph{argumentation semantics}. 

\begin{definition}[Argumentation Semantics] Suppose an argumentation framework $AF=(Arg,Att)$, two sets of arguments $S\cup S'\subseteq Arg$, and some argument $A\in Arg$. We say that
\begin{itemize}
\item $S$ \emph{attacks} $A$ if some argument in $S$ attacks $A$,
\item $S$ \emph{attacks} $S'$ if some argument in $S$ attacks some argument in $S'$,
\item $S$ is \emph{conflict-free} if it does not attack itself,
\item $S$ \emph{defends} $A$ if for each $B$ such that $B$ attacks $A$, $S$ attacks $B$,
\item $S$ is \emph{admissible} if $S$ is conflict-free and defends each argument in it.
\item $S$ is a \emph{preferred extension} of $AF$ if $S$ is a maximal (w.r.t. set inclusion) admissible set of $AF$.
\end{itemize}
\end{definition}

\begin{figure}[ht!]
\centering
\begin{tikzpicture}
        \node[minimum size=1cm] (b) [argNodeIN] at (-2,0) {$A_1$};
        \node[minimum size=1cm] (c) [argNodeIN] at (0,0) {$A_2$};
        \node[minimum size=1cm] (d) [argNodeIN] at (2,0) {$A_3$};
             
         \path
    (c) edge [attackLink] (b)
    (d) edge [attackLink] (c);
    
\end{tikzpicture}
\caption{Example argumentation framework.}
\label{fig:goalmodeling:arg2}
\end{figure}

Let us explain these definitions using the example argumentation framework in Figure~\ref{fig:goalmodeling:arg2}, where $A_2$ attacks $A_1$ and $A_3$ attacks $A_2$. There are two admissible sets: $\{A_3\}$ and $\{A_1, A_3\}$, in which $A_3$ defends $A_1$ against its attacker $A_2$. Sets containing both $A_2$ and either $A_1$ or $A_3$ are not conflict free, and the sets $\{A_1\}$ and $\{A_2\}$ do not defend themselves against $A_2$ and $A_3$, respectively. Given the notion of admissible sets, we can then define our extensions. There are a large number of different semantics to determine which arguments are in an extension; in this article, we choose preferred semantics. In our example from Figure~\ref{fig:goalmodeling:arg2}, there is one preferred extension, namely $\{A_1,A_3\}$. Based on this extension, we can define the status of arguments, acceptable or rejected. 

\begin{definition}[Acceptable and Rejected Arguments] Given an argumentation framework $AF=(Arg,Att)$, an argument $A$ is \emph{acceptable} if $A$ is in the preferred extension of $AF$, and rejected otherwise. 
\end{definition}

This means that, given the argumentation framework in Figure~\ref{fig:goalmodeling:arg2}, arguments $A_1$ and $A_3$ are acceptable and $A_2$ is rejected.

\subsection{Algorithms for argument schemes and critical questions}
\label{sect:algorithms}

In Section~\ref{sect:goalmodeling:logicallanguage} we have developed a simple logical language with which to capture RationalGRL models. We then (Secton~\ref{sect:goalmodeling:argumentationsemantics} formalized an argument as a set of atoms from our language, and we introduced \emph{argumentation semantics} to compute sets of accepted arguments. In this section we develop algorithms for applying argument schemes and critical questions. These algorithms define which arguments should be introduced whenever an argument scheme is instantiated or a critical question is answered. In other words, the algorithms define the exact application of the \textsf{INTRO}, \textsf{REPLACE} and \textsf{DISABLE} operations for the different argument schemes and critical questions. The arguments and attack relations produced by the algorithms then together form an argumentation framework with an associated preferred extension, which can be interpreted as a RationalGRL model. 

\subsubsection*{Algorithms for argument schemes}

In the following algorithms, $id$ is the current highest identifier of the elements, which is increased for each new element that is added, $Args$ is the set of all arguments and $Att$is the set of all attack relations. 

The algorithms for the argument schemes consist of forming a new argument and adding it to the set of arguments. No attack relations are introduced.

\begin{algorithm}[h]
  \caption{Applying AS0: Actor $n_{a}$ is relevant}\label{alg:as0}
  \begin{algorithmic}[1]
    \Procedure{$AS_0$}{$n_{a}$}
    \State $id\gets id+1$\label{alg:as0:1}
    \State $A \gets \{actor(id, n_{a})\}$\label{alg:as0:2}
    \State $Args \gets Args \cup A$\label{alg:as0:3}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:as0} for argument scheme AS0}: The algorithm takes one argument, namely the name $n_{a}$ of the actor. On line~\ref{alg:as0:1} of the algorithm, the global variable $id$ is increased by one. This ensures that each new argument has a unique identifier. 
On line~\ref{alg:as0:2}, the argument for the actor is formed consisting of the statement that there is an actor with $id$ and name $n_{a}$ and on line~\ref{alg:as0:3} this argument is added to the set of arguments $Args$. In Figure~\ref{fig:examples:relevant-actor2}, the application of the argument scheme $AS_0(\text{Development team})$, results in one argument: $\{actor(0, \text{Development team})\}$.

\begin{algorithm}[h]
  \caption{Applying AS1-AS4: Actor $id_{a}$ has intentional element $n_{ie}$ of type $t_{ie}$}\label{alg:as1}
  \begin{algorithmic}[1]
    \Procedure{$AS_1$}{$id_{a}$, $n_{ie}$, $t_{ie}$}
    \State $id\gets id+1$
    \State $A\gets \{IE(id,n_{ie},t_{ie},none), has(id_{a},id)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}
\todo{F}{M}{fix tekst bij aangepast algoritme}
\noindent\textbf{Algorithm~\ref{alg:as1} for argument scheme AS1:} This argument scheme takes two arguments, the identifier $a_{id}$ of the actor and the resource name $n$. The algorithm is similar to the previous one, with the difference that the newly added argument contains the statement $has(a_{id},id)$ as well, meaning that the actor with id $a_{id}$ has element $id$ (which is a resource). As an example, let us formalize the argument corresponding to resource \emph{External library} of actor \emph{Traffic tycoon} in Figure~\ref{fig:transcripts:grl}. First, we assume some id is associated with the actor: $$\{actor(0),name(0,traffic\_tycoon)\}.$$ Then we can formalize the argument for the resource as follows: $$\{resource(1),name(1,external\_library),has(0,1)\}.$$

Argument scheme AS1 to AS4 are all very similar, in the sense that they all assert that some element belongs to an actor. Therefore, we only provide the algorithm for AS1 and we assume the reader can easily construct the remaining algorithms AS2-AS4.

\begin{algorithm}[h]
  \caption{Applying AS5: Goal $g_{id}$ decomposes into tasks $T_1,\ldots,T_n$}\label{alg:as5}
  \begin{algorithmic}[1]
    \Procedure{$AS_5$}{$g_{id}, \{T_1,\ldots,T_n\}, type$}
    \State $T_{id} = \emptyset$\label{alg:as5:1}
    \For{$T_i$ in $\{T_1,\ldots,T_n\}$}
      \If{$\exists_{A\in Args}\label{alg:as5:2} \{task(t_{id}),name(t_{id},T_i)\}\subseteq A$}
        \State $T_{id} \gets T_{id} \cup \{t_{id}\}$
      \Else\label{alg:as5:3}
        \State $id\gets id+1$
        \State $A \gets \{task(id),name(id,T_i)\}$
        \State $Args \gets Args\cup A$
        \State $T_{id} \gets T_{id} \cup \{id\}$
      \EndIf
    \EndFor
    \State $id\gets id+1$\label{alg:as5:4}
    \State $A\gets \{decomp(id, g_{id}, T_{id}, type)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:as5} for argument scheme AS5:}\todo{F}{M}{goal decomposes in 1 task, dtype is aangegevebn op de goal en niet op de decomp, for-loop kan eruit als we aannemen dat de task al bestaat (we nemen in alg 2 trouwens ook gewoon aan dat de actor al bestaat).}
The procedure in Algorithm~\ref{alg:as5} takes three arguments: $g_{id}$ is the identifier of goal $G$, $T=(T_1,\ldots,T_n)$ is a list of decomposing task names, and $type\in\{and,or,xor\}$ is the decomposition type. The difficulty of this algorithm is that each of the tasks are stated in natural language, and it is not directly clear whether these tasks are already in the GRL model or not. Therefore, we have to check for each tasks whether it already exists, and if not, we have to create a new task. On line~\ref{alg:as5:1}, the set $T_{id}$ is initialized, which will contain the ids of the tasks $T_1,\ldots,T_n$ to decompose into. In the for-loop, the if-statement on line~\ref{alg:as5:2} checks whether some argument already exists for the current task $T_i$, and if so, it simply adds the identifier of the task ($t_{id}$) to the set of task identifiers $T_{id}$.\footnote{Note that the existing task may be disabled, but this does not matter, since the decomposition relation will be suppressed for disabled elements.} Otherwise (line~\ref{alg:as5:3}), a new task is created and the new identifier $id$ is added to the set of task identifiers. After the for loop on line~\ref{alg:as5:4}, an argument for the decomposition link itself is constructed, and it is added to the set of arguments $Args$.

Let us explain this algorithm with the XOR-decomposition of goal \texttt{Generate cars} of Figure~\ref{fig:transcripts:grl}. Suppose the following arguments are constructed already:
\begin{itemize}
\item $\{goal(0),name(0,generate\_cars)\},$
\item $\{taks(1),name(1,keep\_same\_cars\}.$
\end{itemize}
Suppose furthermore that someone wants to put forward the argument that goal \texttt{Generate cars} XOR-decomposes into tasks \texttt{Keep same cars} and \texttt{Create news cars}. Formally: $AS_5(0,\{generate\_cars,keep\_same\_cars\},xor)$. The algorithm will first set $T_{id}=\emptyset$, and then iterate over the two task names. For the first task $generate\_cars$, there does not exist an argument $\{task(t_{id}),name(t_{id},generate\_cars)\}$ yet, so a  new argument is created. Suppose the following argument is created: $\{task(2),name(2,generate\_cars)\}.$ After this, 2 is added to $T_{id}$. For the second task an argument exists already, namely $\{task(1),name(1,keep\_same\_cars)\}$, so 1 is simply added to $T_{id}$. After the for loop, we have $T_{id}=\{1,2\}$. Next, the decomposition argument is created, which is $\{decomp(3,0,\{1,2\},xor)\}$. This argument is added to $Args$ and the algorithm terminates.

\begin{algorithm}[h]
  \caption{Applying AS6: Task $t_{id}$ contributes to softgoal $s$}\label{alg:as6}
  \begin{algorithmic}[1]
    \Procedure{$AS_6$}{$t_{id}, s$}
    \If{$\exists_{A\in Args} \{softgoal(i),name(i,s)\}\subseteq A$} \label{alg:as6:if}
        \State $s_{id} \gets i$
    \Else
      \State $id\gets id+1$
      \State $A \gets \{softgoal(id),name(id,t)\}$
      \State $Args \gets Args\cup A$
      \State $s_{id} \gets id$
    \EndIf
    \State $id\gets id+1$
    \State $A\gets \{contr(id, t_{id}, s_{id}, pos)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:as6} for argument scheme AS6:} \todo{F}{M}{if-statement kan eruit als we aannemen dat de softgoal al bestaat.}
The procedure in Algorithm~\ref{alg:as6} takes two arguments: $t_{id}$ is the identifier of task $T$, and $s$ is the softgoal name that is contributed to. The idea behind this algorithm is very similar to the previous one, with the difference that in the current algorithm we create a single relation, while we created a set of relations in the previous algorithm. First, the if-statement on line~\ref{alg:as6:if} checks whether the softgoal exists already, and if not, an argument is added for it. This ensures that all softgoals have corresponding arguments. After the if-statement, the argument for the contribution link is created and it is added to the set of arguments $Args$. 

Let us again illustrate this with a simple example from Figure~\ref{fig:transcripts:grl}. Suppose the following argument exists already: $\{task(0),name(0,keep\_same\_cars\}$, and suppose someone would like to add an argument that the task \texttt{Keep same cars} contributes positively to softgoal \texttt{Dynamic simulation}, i.e. $AS_6(0,dynamic\_simulation)$. The algorithm first checks whether an argument already exists for the softgoal, and when it finds out it does not exist, creates the argument $\{softgoal(1),name(1,dynamic\_simulation)\}$ and adds it to $Args$. Then, the argument for the contribution is added to $Args$ as well, which is $\{contr(2,0,1,pos)\}$.

\emph{Algorithms for argument schemes AS7-AS11:} \todo{F}{M}{kunnen algoritme \ref{alg:as6} en de algoritmes voor AS7-AS11 niet in 1 algoritme voor $EL$? (op dezelfde manier als alg. \ref{alg:as1} voor alle IE)}
The algorithms for $AS7$ to $AS11$ all have a very similar structure as Algorithm~\ref{alg:as6} and have therefore been omitted. Again, we assume the reader can reconstruct them straightforwardly.

\subsubsection*{Algorithms for critical questions}

We now develop algorithms for our critical questions. \todo{F}{M}{check of alle CQ nummers e.d. nog kloppen.} Recall that answering a critical question can have four effects, and we discuss each of these effects separately.

\begin{algorithm}[h]
  \caption{Applying DISABLE: Element $i$ is disabled}\label{alg:disable}
  \begin{algorithmic}[1]
    \Procedure{DISABLE}{$i$}
    \State $id\gets id+1$
    \State $A\gets \{disabled(i))\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:disable} (\textsf{DISABLE}) for critical questions CQ0-CQ5a, CQ6a, CQ7a, CQ8, CQ11, and CQ12:} 
\todo{F}{M}{Wat ik dacht is dat we zeggen dat ``element $n$ is disabled because $r$'' en dan voegen we een nieuwe ARG toe met $disable(id,r)$ welke het argument met naam $n$ aanvalt}
The disable operation consists of adding an argument stating the GRL element with identifier $i$ is disabled. Let us reconsider the example of Figure~\ref{fig:examples:relevant-actor}. This example consists of an instantiation of argument scheme AS0, which is attacked by an argument that resulted from answering critical question. The instantiation of AS0 leads to the argument $A=\{actor(0),name(0,dev\_team\}$. After applying $DISABLE(0)$ we obtain the arguments: $$Args=\{\{actor(0),name(0,dev\_team\}, \{disabled(0)\}\}.$$ Note that our implementation of this attack does not lead to an actual attack in the argumentation framework.

\begin{algorithm}[h]
  \caption{Answering CQ5b: ``Does goal $G$ decompose into any other tasks?'' With: ``Yes, namey into tasks $t_1,\ldots,t_k$''}\label{alg:cq5b}
  \begin{algorithmic}[1]
    \Procedure{CQ5b}{$g_{id},\{i_1,\ldots,i_n\}, type, \{t_1,\ldots,t_k\}$}
    \State $T_{id} = \{i_1,\ldots,i_n\}$
    \For{$t_i$ in $\{t_1,\ldots,t_k\}$}\label{alg:cq5b:for1}
      \If{$\exists_{A\in Args} \{task(t_{id}),name(t_{id},t_i)\}\subseteq A$}
        \State $T_{id} \gets T_{id} \cup \{t_{id}\}$
      \Else
        \State $id\gets id+1$
        \State $A \gets \{task(id),name(id,t_i)\}$
        \State $Args \gets Args\cup A$
        \State $T_{id} \gets T_{id} \cup \{id\}$
      \EndIf
    \EndFor
    \State $id\gets id+1$
    \State $A_{new} = \{decomp(id, g_{id}, T_{id}, type)\}$\label{alg:cq5b:newarg}
    \For{$A$ in $\{decomp(\_,g_{id},\_,\_)\}\subseteq A\mid A\in Args\}$}\label{alg:cq5b:for2}
      \State $Att\gets Att \cup \{(A_{new},A)\}$
    \EndFor
    \State $Args \gets Args \cup \{A_{new}\}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm~\ref{alg:cq5b} (\textsf{REPLACE}) for critical questions CQ5b:} \todo{F}{M}{Kan verandert worden: decmp relaties zijn per task en je introduceert altijd een nieuwe dus de check of hij al betsaat kan eraf.} This algorithm is executed when critical question CQ5b is answered, which is a critical question for argument scheme AS5. Therefore, it assumes an argument for a goal decomposition already exists of the following form (see Algorithm~\ref{alg:as5}): $$\{decomp(d, g_{id}, \{i_1,\ldots,i_n\},type).$$  The goal of the algorithm is to generate a new argument of the form $decomp(d, g_{id}, \{i_1,\ldots,i_5\}\cup \{j_1,\ldots,j_k\}, type)$, where $\{j_1,\ldots,j_k\}$ are the identifiers of the additional decomposing tasks $\{t_1,\ldots,t_k\}$.

The algorithm takes as input the goal identifier $g_{id}$, the set of existing decomposing task identifiers $i_1,\ldots,i_n$, the decomposition type, and the names of the new tasks $t_1,\ldots,t_k$ that should be added to the decomposition. The first part of the algorithm is familiar from Algorithm~\ref{alg:as5}: For each task name we check whether it already exists as an argument (line 4), and if it doesn't (line 6) we add a new argument for it. After the for-loop (line 13), a new argument is created for the new decomposition relation (14). After this, the for-loop on line 15 ensures that the new argument attacks all previous arguments for this decomposition (note that the variable ``$\_$'' means ``do not care''). Only at the very end the new argument is added (line 18), to ensure it does not attack itself after the for loop of line 15-17. 

An example of this algorithm is shown in Figure~\ref{fig:examples:cq5b}.\footnote{Note that part of the arguments (the statements about actors) have been omitted from the figure for readability.} Before the critical question is applied, the following arguments have been put forward:
\begin{itemize}
\item $\{goal(0),name(0,show\_simulation)\}$
\item $\{task(1),name(1,generate\_traffic)\}$
\item $\{task(2),name(2,compute\_lights)\}$
\item $\{decomp(3,0,\{1,2\},and)\}$.
\end{itemize}

Next, Algorithm~\ref{alg:cq5b} is called as follows: $CQ5b(0,\{1,2\},and,\{show\_controls\})$. That is, the existing decomposition is challenged by stating that goal $show\_simulation$ not only decomposes into $generate\_traffic$ and $compute\_lights$, but it also decomposes into $show\_controls$. Since this task does not exist yet, it is created by the algorithm, which also ensures the new argument for the decomposition link attacks the previous argument for the decomposition link.

\begin{figure*}[ht!]
\centering
        \begin{tikzpicture}
        \node (a0) [argNodeIN,minimum width=1.5cm] at (-5,0) {
        	\smallargtext{AS3}{$\{goal(0),$\\$name(0,show\_sim\}$}
        };
        \node (a1) [argNodeIN] at (0,0) {
        \smallargtext{AS2}{$\{task(1),$\\$name(1,gen\_traffic\}$}
        };
        \node (a2) [argNodeIN] at (5,0) {
        \smallargtext{AS2}{$\{task(3),$\\$name(2,show\_ctrls\}$}
        };
        \node (a2a) [argNodeIN] at (-2.5,-2) {
        \smallargtext{AS2}{$\{task(2),$\\$name(2,comp\_lights\}$}
        };
        \node (a3) [argNodeOUT] at (-3,-4) {$\{decomp(3,0,\{1,2\},and\}$
        };
        \node (a4) [argNodeIN] at (3,-4) {$\{decomp(3,0,\{1,2,3\},and\}$
        };
         
         \path
    (a4) edge [attackLink] (a3)
    (a3) edge [CQLink, bend right=50] node [below,draw=none] {CQ5b} (a4)
    (a4) edge [CQLink] node [left,draw=none] {CQ5b} (a2);
\end{tikzpicture}
\caption{Example of applying critical question CQ5b (Algorithm~\ref{alg:cq5b})}
\label{fig:examples:cq5b}
\end{figure*}

\noindent\textbf{Algorithms for critical questions CQ10a and CQ10b (REPLACE)}: These algorithms have a very similar structure as Algorithm~\ref{alg:cq5b} and have therefore been omitted.

\begin{algorithm}[h]
  \caption{Answering CQ13: ``Is the name of element $i$ clear?'' With: ``No, it should be $n$''}\label{alg:cq13}
  \begin{algorithmic}[1]
    \Procedure{CQ13}{$i, n$}
    \State $ArgsN \gets\{ A\in Args \mid name(i,x)\in A\}$
    \State $B\gets B'\backslash \{name(i,\_)\}$ with $B'\in ArgsN$
    \State $A \gets B \cup \{name(i,n)\}$
    \State $Args \gets Args \cup \{A\}$
    \For{$C$ in $ArgsN$}
      \State $Att\gets Att \cup \{(A,C)\}$
    \EndFor
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithms for critical question CQ13 (REPLACE):} \todo{F}{M}{deze moet aangepast worden nu de naam in het element staat} This algorithm is used to clarify/change the name of an element. It takes two parameters: the element identifier $i$ and the new name $n$. The idea behind the algorithm is that we construct a new argument for $n$, and to ensure that this argument attacks all previous arguments for giving a name to this element. Here we can use the following fact: Suppose $Args$ is a set of arguments, each containing an atom about the name for an element $i$, i.e. for all $A\in Args: name(i,_)\in Args$, then all arguments in $Args$ are the same except for the $name$ atoms, i.e. for all $A,B\in Args: A\backslash\{name(i,_)\} = B\backslash\{name(i,_)\}$. This means that if we would like to attack every argument of $Args$ with a new argument that replaces the $name$ atom, we can simply take any argument in $Args$, remove the previous $name$ atom, add the new one and attack all arguments in $Args$. This is exactly what the algorithm does.


On line 2, all arguments that have been put forward for this element and contain $name(i,x)$ are collected into the set $ArgsN$. On line 3, some arguments $B'\in ArgsN$ minus the $name$ statement is assigned to $B$ (note that it does not matter which one we pick), and on line 4 $B$ is joined with the new $name$ statement and stored in $A$, which is then added to the set of arguments $Args$. The for-loop on lines 6-8 ensures all previous arguments for names of the element are attacked by the new argument.

\begin{figure}[ht!]
\centering
        \begin{tikzpicture}[->]
        \node (a0a) [argNodeIN] at (-2,2) {
        	\longargtext{AS0}{$\{actor(0),name(0,student)\}$}
        };
        \node (a0) [argNodeOUT] at (-2,0) {
        	\longargtext{AS2}{$\{task(1),name(1,create\_road),has(0,1)\}$}
        };
        \node (a1) [argNodeOUT] at (-2,-2) {
        	\longargtext{AS2}{$\{task(1),name(1,choose\_pattern),has(0,1)\}$}
        };
        \node (a2) [argNodeOUT] at (-2,-4) {
        	\longargtext{AS2}{$\{task(1),name(1,pattern\_pref),has(0,1)\}$}
        };
        \node (a3) [argNodeIN] at (-2,-6) {
        	\longargtext{AS2}{$\{task(1),name(1,road\_pattern),has(0,1)\}$}
        };
\begin{pgfonlayer}{background}
         \path
    (a1) edge[attackLink] (a0)
    (a2) edge[attackLink] (a1)
    (a2) edge[attackLink, bend right=20] (a0)
    (a3) edge[attackLink] (a2)
    (a3) edge[attackLink, bend right=20] (a1)
    (a3) edge[attackLink, bend right=40] (a0);
\end{pgfonlayer}

	\path
	(a0) edge [CQLink, bend right=50] node [left,draw=none] {CQ13} (a1)
    (a1) edge [CQLink, bend right=50] node [left,draw=none] {CQ13} (a2)
    (a2) edge [CQLink, bend right=50] node [left,draw=none] {CQ13} (a3);
\end{tikzpicture}
\caption{Applying critical question CQ13 (Algorithm~\ref{alg:cq13}) to the example in Figure~\ref{fig:examples:clarification}.}
\label{fig:examples:clarification:formal}
\end{figure} 

An example of of Algorithm~\ref{alg:cq13} is shown in Figure~\ref{fig:examples:clarification:formal}. Let us consider the last application of CQ13 (bottom argument). Before this application, the following arguments have been put forward:
\begin{itemize}
\item $A_1$: $\{actor(0),name(0,student)\}$
\item $A_2$:$\{task(1),name(1,create\_road),has(0,1)\}$
\item $A_3$ $\{task(1),name(1,choose\_pattern),has(0,1)\}$
\item $A_4$:$\{task(1),name(1,pattern\_pref),has(0,1)\}$
\end{itemize}
The algorithm is now called as follows: $CQ13(1,road\_pattern)$, i.e., the new name of the element should be $road\_pattern$. Let us briefly run through the algorithm. After executing line 2 we obtain $ArgsN=\{A_2,A_3,A_4\}$, since only those arguments contain $name(1,\_)$. Next, on line 3, $B=\{task(1),has(0,1)\}$, i.e., $B$ is the general argument for the task without the $name$ statement. After line 4 we have $$A=\{task(1),has(0,1),name(1,road\_pattern),$$ which is added to $Args$ and attacks arguments $A_2,A_3$, and $A_4$. 

\noindent\textbf{Algorithms for critical questions CQ6b, CQ6c, CQ6d, CQ7b, and CQ9 (INTRO):} The introduction algorithms for the critical questions are all very similar to the INTRO algorithms for argument schemes (Algorithm~\ref{alg:as1}). They have therefore been omitted.

\begin{algorithm}[h]
  \caption{Generic counterargument to argument $A$}\label{alg:cq6b}
  \begin{algorithmic}[1]
    \Procedure{Attack}{$A$}
    \State $A_{new} = \{\}$
    \State $Args \gets Args \cup \{A_{new}\}$
    \State $Att \gets Att \cup \{(A_{new},A)\}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\noindent\textbf{Algorithm for $Att$ (Generic counter argument:} \todo{F}{M}{zoals je in Def 1 kunt zien heb ik generic arguments een id en een naam gegeven. Je moet ze namelijk kunnen aanvallen! (en de lege set kun je niet aanvallen want die is niet uniek te identificeren). algoritme moet dus aangepast worden}Applying a generic counter argument is very simple, and simply results on an attack on the original argument. We illustrate this by continuing our example from Figure~\ref{fig:examples:relevant-actor2:formal} (Algorithm~\ref{alg:as0}). The example is shown in Figure~\ref{fig:examples:relevant-actor2:formal}, where we see that a generic counter argument simply attacks the argument to disable the actor.

\begin{figure}[ht!]
\centering
        \begin{tikzpicture}
        \node (a0) [argNodeIN] at (-3.7,0) {
        	\smallargtext{AS0}{$\{actor(0),name(0,dev\_team\}$}
        } ;
        \node (a1) [argNodeOUT] at (-3.7,-2){
        	\argtext{DISABLE}{$\{disabled(0)\}$}
        };
        \node (a2) [argNodeIN] at (-3.7,-4){
        	\argtext{Att}{$\{\}$}
        };
         \path
    (a0) edge [CQLink, bend right=50] node [left,draw=none] {CQ0} (a1)
    (a1) edge [CQLink, bend right=50] node [left,draw=none] {Att} (a2)
    (a2) edge [attackLink] (a1);
\end{tikzpicture}
\caption{Formalization of the arguments in Figure~\ref{fig:examples:relevant-actor2}.}
\label{fig:examples:relevant-actor2:formal}
\end{figure}

\subsection{Constructing GRL models}
\label{sect:rationalGRL-GRL}
\todo{F}{F,M}{Dit is snel getypt, moet nog checken of het klopt.}

\begin{definition}[RationalGRL model] A RationalGRL model \mathcal{R} is an argumentation framework $AF=(Args,Att)$ where all arguments in $Args$ and attacks in $Att$ are based on algorithm X-XX.  
\end{definition}

\begin{definition}[GRL model] A GRL model $\mathcal{M}$ based on a RationalGRL model $\mathcal{R}$ is the preferred extension of $\mathcal{R}$.  
\end{definition}

Constructing GRL models from the arguments is extremely simple: We simply compute the extensions of the argumentation frameworks, and collect all atomic sentences in the accepted arguments. This forms out GRL model. Let us briefly do so for the examples of the previous subsection:
\begin{itemize}
\item
Figure~\ref{fig:examples:relevant-actor:formal}: Since there are no attacks between the arguments, all atomic sentences are accepted. This results in the following specification: 
\begin{quote}
\begin{verbatim}
actor(0).
name(0,dev_team).
disabled(0).
\end{verbatim}
\end{quote}
This again corresponds to the GRL model on the right-hand side of Figure~\ref{fig:examples:relevant-actor}.
\item
Figure~\ref{fig:examples:cq5b}: There is one rejected argument and five accepted ones. The resulting specification is:
\begin{quote}
\begin{verbatim}
goal(0). name(0,show_simulation).
task(1). name(1,generate_traffic).
task(2). name(2,compute_lights).
task(3). name(3,show_controls).
decomp(3,0,{1,2,3},and).
\end{verbatim}
\end{quote}
\item Figure~\ref{fig:examples:clarification:formal}: There are only two accepted arguments. The resulting specification is:
\begin{quote}
\begin{verbatim}
actor(0). name(0, student).
task(1).  name(1,road_pattern).
has(0,1).
\end{verbatim}
\end{quote}
This corresponds to the right-hand GRL model of Figure~\ref{fig:examples:clarification}.
\item Figure~\ref{fig:examples:relevant-actor2:formal}. There are two accepted arguments, but the \emph{generic counterargument} does not contain any formulas. Therefore the resulting specification is:
\begin{quote}
\begin{verbatim}
actor(0).
name(0,dev_team).
\end{verbatim}
\end{quote}
This corresponds to the right-hand GRL model of Figure~\ref{fig:examples:relevant-actor2}.
\end{itemize}