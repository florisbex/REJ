\section{RationalGRL: Logical Framework}
\label{sect:formalframework}

In Section~\ref{sect:gmas} we developed a list of critical questions and argument schemes by analyzing transcripts of discussions about the development of a traffic simulator. The resulting list is shown in Table~\ref{table:argument-schemes}. We then presented the RationalGRL framework in secton~\ref{sect:overview}, consisting of a modeling language, a metamodel, and various examples of using the argument schemes and critical questions. In section~\ref{sect:meth+tool} we explained how this framework can be used by practitioners by explaining the methodology and tool support.

In this section we present a formalization of RationalGRL based on formal logic. This is done for multiple reasons: (i) Most approaches in formal argumentation use formal logic, allowing us to employ existing technique directly in order to compute which arguments are accepted and which are rejected, (ii) we can be more precise about how critical questions are answered, (iii) we can show that RationalGRL models can be translated in to valid GRL models in a very precise way, and (iv) the formal approach is a basis for automating the framework in terms of tool support.

In the first two subsections we formalize a static representation of our framework: We provide a formal specification of a GRL model based on the GRL metamodel (Section \ref{sect:goalmodeling:logicallanguage}) in the first subsection, and we extend this with arguments and attack links in the second subsection, hereby obtaining a formal specification of a RationalGRL model. 

In the third subsection we develop algorithms in order to translate a GRL model into a RationalGRL model, and visa versa.

In the fourth and final subsection we turn to the dynamics of our framework. We develop algorithms for instantiating argument schemes and for answering critical questions. 

\subsection{Formal Specification of GRL}
\label{sect:formalframework:grl}

In this subsection we formalize a GRL model based on the GRL metamodel and the jUCMNav implementation. We first formalize elements of GRL (intentional elements and actors), and then formalize the links.

\subsubsection{Intentional Element, beliefs and actors}

We start with some general definition that we use in subsequent definitions.

\begin{definition}[General definitions]
\label{def:set-definitions}
Throughout this section, we adopt the convention that variables start with a lowercase letter (e.g, $id, i, j, name, ie, goal$), and sets and constants start with an uppercase letter (e.g., $Type, AND, Goal$).

We define the following sets:
\begin{itemize}
\item $Types = \{Softgoal, Goal, Task, Resource\}$,
\item $Elements = Type \cup \{Actor, Contr, Dependency, Decomp, Belief\}$
\item $Names$ is a finite set of strings.
\item $DecompTypes = \{AND,OR,XOR\}$.
\item $ContribValues = \{Break, Hurt, Some\ nega-$ $tive, Unknown, Some\  positive, Help, Make\},$
\end{itemize}
\end{definition}

Next we define an intentional element.

\begin{definition}[Intentional Element]
\label{def:ie}
An intentional element $ie\in \mathbb{N}\times Types\times Names\times DecompType$ is a relation, where $ie = (id, type, name, decomptype)$ means:
\begin{itemize}
\item $id\in \mathbb{N}$ is a unique identifier for the element,
\item $type\in Types$ specifies the type of the element,
\item $name \in Names$ is a string description of the element,
\item $decomptype\in DecompType$ refers to the type of decomposition.\footnote{Note that the decomposition type is relevant only if the element is in fact decomposed into other elements, but since the jUCMNav implementation defines the decomposition type on the element, we do the same here.}
\end{itemize}
A set of intentional elements is denoted by $IE$.
\end{definition}

The definition above is sufficient to capture all intentional elements used in GRL. However, we present some syntactic sugar in the next definition by abbreviating the definition above in various ways. This does not add anything new to the previous definition, but it simplifies some of the notation.

\begin{definition}[Notation]
\label{def:notation}
We adopt three conventions simplifying our notation:
\begin{itemize}
\item
We refer to the element of a tuple using the dot (".") notation. That is, we may for instance refer to the id, type, name and decomposition type of an $IE$ with respectively $ie.id$, $ie.type$, $ie.name$, and $ie.decomptype$.
\item 
We refer to a set of elements with the same id $i$  using the $i$ subscript on the set. For instance a set of IEs with id $i$ is denoted by $E_i$, and if this is a single element, we denote it by $ie_i$\footnote{In GRL, there always exists at most one element for every id (see Def.~\ref{def:grl-model}), in RationalGRL, however, this condition does not hold (see Def.~\ref{def:rationalgrl-model}).} For instance, we may refer to the intentional element $ie = (0, Goal, \text{Make profit}, AND)$ with $ie_0$ and write $ie_0.type = Goal$, $ie_0.name = \text{Make profit}$, and $ie_0.decompositiontype = AND$. 
\item
We can also refer to intention elements of a specific type simply by $type_{id}$. For instance, we can abbreviate the element in the previous item with $goal_0$ and write $goal_0.name = \text{Make profit}$, and $goal_0.decomptype = AND$.
\end{itemize}
\end{definition}

\paragraph{Rationale and example} Throughout this section we use the example in Figure~\ref{fig:example-small}, which we reproduce in Figure~\ref{fig:example-small2}. Our formalization of GRL is very much in line with the way in which GRL models are represented in the open-source Eclipse-based tool jUCMNav.\footnote{See \url{http://jucmnav.softwareengineering.ca/foswiki/ProjetSEG}} This tool is actively developed and has a rich number of features for the analysis of both GRL and URN models. By keeping our formalization in line with this tool, we simplify the translation step from RationalGRL to GRL.

Some of the IEs in Figure~\ref{fig:example-small2} can be formalized using Def.~\ref{def:ie} as follows:
\begin{itemize}
\item $(2, goal, \text{Generate traffic}, XOR)$: This represents the goal ``Generate traffic'', which is XOR-decomposed. Note the identifier is not shown in the GRL model, but it is stored internally.
\item $(5, resource, \text{Car objects}, AND)$: Although this element does not decompose into any other elements, it still contains an AND-decomposition. Our motivation for this choice is that it simplifies the formalization of decomposition links. It is in line with jUCMNav implementation, the open source implementation of GRL.
\end{itemize}

Using the short-hand notation defined in Def.~\ref{def:notation}, we can make the following statements:
\begin{itemize}
\item $ie_2.name = \text{Generate traffic}$
\item $goal_2.decomptype = XOR$
\item $resource_5.name = \text{Car objects}$
\end{itemize}

\begin{figure}[ht]
\centering
\includegraphics[width=\columnwidth]{img/Example1.pdf}
\caption{Partial GRL Model of the traffic simulator example}
\label{fig:example-small2}
\end{figure} 

\begin{definition}[Belief]
\label{def:belief}
A belief $bel\in \mathbb{N}\times Names$ is a relation where $bel=(id,name)$ means:
\begin{itemize}
\item $id\in\mathbb{N}$ is the identifier of the belief,
\item $name\in Names$ is a string description of the belief.
\end{itemize}
\end{definition}

\paragraph{Rational and example} Beliefs are different from IEs in the sense that they are not being used in decompositions, dependencies, or contributions. They merely provide additional explanation for an element. The only belief in Figure~\ref{fig:example-small2} is formalized as $(1, \text{Not scientifically correct})$.

\begin{definition}[Actor]
\label{def:actor}
An actor $act \in \mathbb{N}\times Names$ is a relation where $act=(id,name)$ means:
\begin{itemize}
\item $id\in\mathbb{N}$ is the identifier of the actor, 
\item $name\in Names$ is a string description of its name.
\end{itemize}

Similar to intentional elements, we may refer to $act = (id,name)$ with $act_{id}$ and write $act_{id}.name$ to refer to its name.

A set of actors is denoted by $Act$.
\end{definition}

\paragraph{Rationale and example} An actor is simply a pair consisting of its identifier and its name. The relation between actors and their intentional element is formalized in the next definition. 

We can formalize the actor of Figure~\ref{fig:example-small2} as $act=(0,\text{Traffic Simulator})$, and we can for instance state $act_0.name = \text{Traffic Simulator}$.

\begin{definition}[Actor-IE Relations]
\label{def:act-ie-relation}
An \emph{Actor-IE relation} $r_{ActIE}\in\mathbb{N}\times\mathbb{N}$ is a relation $(i,j)$ meaning that an actor with id $i$ has intentional element with id $j$.

A set of Actor-IE relations is denoted by $R_{ActIE}$.
\end{definition}

\paragraph{Rationale and example} The previous definition specifies relations between actors and intentional elements. Each actor can own one or multiple intentional elements, but each intentional element can only be owned by at most one actor (we will make these assumptions explicit in Def.~\ref{def:valid-grl-model}).

In Figure~\ref{fig:example-small2}, recall we formalized two IEs and the actor as follows:
\begin{itemize}
\item $(2, goal, \text{Generate traffic}, XOR)$
\item $(5, resource, \text{Car objects}, AND)$
\item $(0, \text{Traffic Simulator})$
\end{itemize}

We can then formalize the Actor-IE relationships for these elements as: $(0,2)$ and $(0,5)$.

\subsubsection{Links}

At this point we have defined all intentional elements in GRL and a containment relation between actors and intentional elements. We now turn to the GRL links.

\begin{definition}[Belief link]
\label{def:link:belief}
A \emph{belief} link: $bellink\in \mathbb{N}\times\mathbb{N}\times\mathbb{N}$ is a relation such that $dep = (i,j,k)$ means
\begin{itemize}
\item $i\in \mathbb{N}$ is the unique identifier of the link,
\item $j\in \mathbb{N}$ is the unique identifier of the belief element,
\item $k\in \mathbb{N}$ is the unique identifier of the IE.
\end{itemize}
Intuitively, $bellink = (i,j,k)$ means that $bel_i$ is a belief for $ie_j$.

A set of belief links is denoted by $Bellink$.
\end{definition}

\paragraph{Rationale and example} The belief links can only be used to connect a belief with an intentional element. However, this is not made explicit in the definition above. We make this assumption, together with various assumption, explicit in the definition of a \emph{valid GRL model} (Def.~\ref{def:valid-grl-model}). Figure~\ref{fig:example-small2} does not contain any belief links.

\begin{definition}[Contribution Link]
\label{def:link:contrib}
A \emph{contribution} link: $contrib\in \mathbb{N}\times\mathbb{N}\times\mathbb{N}\times Contribvalues$ is a relation such that $contrib = (i,j,k,value)$ means
\begin{itemize}
\item $i\in \mathbb{N}$ is the unique identifier of the link,
\item $j\in \mathbb{N}$ is the unique identifier of the IE from which the contribution originates,
\item $k\in \mathbb{N}$ is the unique identifier of the IE to which is contributed.
\item $value\in ContribValues$ is the strength of the contribution.
\end{itemize}
Intuitively, $contrib = (i,j,k,value)$ means that $ie_i$ contributes to $ie_j$ with $value$.

A set of contribution links is denoted by $Contrib$.
\end{definition}

\paragraph{Rationale and example} Similar to IEs, links have identifiers as well. In Fig.~\ref{fig:example-small2}, there are two contribution links. First, let us formalize the related IEs:
\begin{itemize}
\item $(3, softgoal, \text{Realisitc simulation}, AND)$
\item $(4, softgoal, \text{Simple design}, AND)$
\item $(6, task, \text{Create new cars}, AND)$
\end{itemize}

We can formalize the contribution links as $(9, 6, 3, \text{Help})$ and $(10, 6, 4, \text{Hurt})$.

\begin{definition}[Decomposition Link]
\label{def:link:decomp}
A \emph{decomposition} link: $decomp\in \mathbb{N}\times\mathbb{N}\times\mathbb{N}$ is a relation such that $decomp = (i,j,k)$ means
\begin{itemize}
\item $i\in \mathbb{N}$ is the unique identifier of the link,
\item $j\in \mathbb{N}$ is the unique identifier of the decomposing IE,
\item $k\in \mathbb{N}$ is the unique identifier of the IE that is being decomposed.
\end{itemize}
Intuitively, $decomp = (i,j,k)$ means that $ie_i$ decomposes $ie_j$.\footnote{Note that the decomposition type is defined on $IE_{k}$, see Definition~\ref{def:ie}.}

A set of decomposition links is denoted by $Decomp$.
\end{definition}

\paragraph{Rationale and example} Decomposition links are simpler than contribution links, because they only contain information about which elements are being connected. Recall that the decomposition type is stored in the element that is being decomposed. In order to formalize the decomposition links in Figure~\ref{fig:example-small2}, let us first formalize the related IEs:
\begin{itemize}
\item $(5, goal, \text{Generate traffic}, XOR)$
\item $(6, task, \text{Create new cars}, AND)$
\item $(7, task, \text{Keep same cars}, AND)$
\end{itemize}
The decomposition links can be formalized as $(11, 6, 5)$ and $(12, 7, 5)$.

\begin{definition}[Dependency Link]
\label{def:link:dependency}
A \emph{dependency} link: $dep\in \mathbb{N}\times\mathbb{N}\times\mathbb{N}$ is a relation such that $dep = (i,j,k)$ means
\begin{itemize}
\item $i\in \mathbb{N}$ is the unique identifier of the link,
\item $j\in \mathbb{N}$ is the unique identifier of the dependee IE,
\item $k\in \mathbb{N}$ is the unique identifier of the dependent IE.
\end{itemize}
Intuitively, $dep = (i,j,k)$ means that $ie_j$ depends on $ie_j$.

A set of dependency links is denoted by $Dep$.
\end{definition}

\paragraph{Rationale and example} The representation of dependency links is exactly the same as decomposition links. In Figure~\ref{fig:example-small2}, let us formalize the IEs related to the only dependency link:
\begin{itemize}
\item $(2, resource, \text{Car objects}, AND)$
\item $(5, goal, \text{Generate traffic}, XOR)$
\end{itemize}

The dependency link between these two elements is formalized as $(8, 5, 2)$.

\begin{definition}[GRL Model]
\label{def:grl-model}
A \emph{GRL model} $GRL=(IE, Bel, Act, R_{ActIE}, Bellink, Contr, Decomp, Dep)$ consists of:
\begin{itemize}
\item A set $IE$ of intentional elements (Def.~\ref{def:ie}),
\item A set $Bel$ of beliefs (Def.~\ref{def:belief}),
\item A set $Act$ of actors (Def.~\ref{def:actor}),
\item A set $R_{ActIE}$ of Actor-IE relations (Def.~\ref{def:act-ie-relation}),
\item A set $Bellink$ of belief links (Def.~\ref{def:link:belief}),
\item A set $Contr$ of contribution links (Def.~\ref{def:link:contrib}),
\item A set $Decomp$ of decomposition links (Def.~\ref{def:link:decomp}),
\item A set $Dep$ of dependency links (Def.~\ref{def:link:dependency}).
\end{itemize}
\end{definition}

\paragraph{Rationale and example} The definition of a GRL model collects all the previously defined tuples into a single definition. For completeness, we now provide the full specification of Figure~\ref{fig:example-small2}. This model is formalized as
 $GRL=(IE, Bel, Act, R_{ActIE}, Bellink, Contr, Decomp, Dep)$ where:
\begin{flalign*}
&IE=&\{&(2, task, \text{Car objects}, AND),&\\
&   &  &(3, softgoal, \text{Realistic simulation}, AND),&\\
&   &  &(4, softgoal, \text{Simple design}, AND),&\\
&   &  &(5, goal, \text{Generate traffic}, XOR),&\\
&   &  &(6, task, \text{Create new cars}, AND),&\\
&   &  &(7, task, \text{Keep same cars}, AND)\}&\\
&Bel=& &\{(1, \text{Not scientifically correct})\}&\\
&Act=& &\{(0, \text{Traffic Simulator})\}&\\
&R_{ActIE}=& &\{(0,i)\mid 2\le i\le 7\}&\\
&Bellink = & &\emptyset&\\
&Contr=& &\{(9, 6, 3, \text{Help}), (10, 6, 4, \text{Hurt})\}&\\
&Decomp=& &\{(11, 6, 5), (12, 7, 5)\}&\\
&Dep=& &\{(8, 5, 2)\}&
\end{flalign*}


\begin{definition}[Valid GRL Model]
\label{def:valid-grl-model}
A GRL model $GRL=(IE, Act, R_{ActIE}, Contr, Decomp, Dep)$ (Def.~\ref{def:grl-model}) is a \emph{valid GRL model} iff the following conditions are satisfied:
\begin{enumerate}
\item ids are globally unique across IEs, Links, and Actors, i.e., let $X,Y\in \{IE,Act, Contr, Decomp, Dep\}$. For all $X_i$ and $Y_j$: if $i=j$ then $X=Y$ and $X_i=Y_j$.
\item All intentional elements of actors exist: $\forall (i,j)\in R_{ActIE}: act_i \in Act \wedge ie_j \in IE$.
\item An intentional element belongs at most to one actor: $\forall ie_i\in IE: |\{(k,i)\in R_{ActIE}\}| \le 1$.
\item Contribution links connect intentional elements: $\forall (i,j,k,value)\in Contrib: \{ie_j,ie_k\}\subseteq IE$.
\item Decomposition links connect intentional elements: $\forall (i,j,k)\in Decomp: \{ie_j,ie_k\}\subseteq IE$.
\item Dependency links connect intentional elements: $\forall (i,j,)\in Dep: \{ie_j,ie_k\}\subseteq IE$.
\end{enumerate}
\end{definition}

\paragraph{Rationale and example} The definition of a GRL model (Def.~\ref{def:grl-model}) comes with various implicit assumptions in order to form a valid GRL model. For instance, if an Actor-IE relation $(i,j)$ occurs in a GRL model, then there should exist an actor with id $i$, and there also should exist an IE with id $j$. We make these assumptions explicit in this definition.

Let us briefly verify that our previous formalization of Figure~\ref{fig:example-small2} satisfies all the constraints of Def.~\ref{def:valid-grl-model}:
\begin{enumerate}
\item All elements in the formalization have different ids, so this constraint is satisfied.
\item $R_{ActIE}$ contains one element $(0,i)$ for each IE with id $i$, so this constraint is satisfied as well. Note that other elements (beliefs and links) are not related to actors. This is in line with the jUCMNav implementation.
\item Since we have only one actor with id 0, and this is the only actor that appears in $R_{ActIE}$, this constraint is satisfied.
\item The contribution links connect elements with ids 3, 4, and 6, which are all IEs.
\item The decomposition links connect elements with ids 5, 6, and 7, which are all IEs.
\item The dependency link connects id 2 with 5, which are both IEs.
\end{enumerate}

\subsection{Formal specification of RationalGRL}
\label{sect:formalframework:rationalgrl}

In order to develop a logical framework for RationalGRL, we extend the GRL logical framework of the previous section by adding three elements (see Figure~\ref{fig:rationalgrllegend}):
\begin{itemize}
\item A new element called \emph{generic argument},
\item A new link called \emph{attack link}
\end{itemize}

Following the RationalGRL metamodel (Figure~\ref{fig:metamodel}), we define an \emph{Argument} as either a generic argument or any of the GRL elements, and we define attack relations between arguments. Thus, a RationalGRL model is simply a set of arguments and attack relations. We use \emph{argumentation semantics} to compute extensions, which are sets of accepted arguments.

We start with the new element which we call the \emph{Generic Argument}.

\begin{definition}[Generic Argument]
\label{def:generic-argument}
A generic argument $ga \in \mathbb{N}\times Names$ is a relation such that $ga=(id, name)$ means
\begin{itemize}
\item $id\in \mathbb{N}$ is the identifier of the generic argument,
\item $name\in Names$ is a string description of its name.
\end{itemize}
We may refer to the argument with id $i$ simply with $ga_i$. A set of arguments is denoted by $GA$.
\end{definition}

Note that one of the constraints of a GRL model (Def.~\ref{def:grl-model}) is that GRL links (Def.~\ref{def:link:contrib},~\ref{def:link:decomp}, and~\ref{def:link:dependency}) should connect IEs, which means that in GRL generic arguments cannot be connected with GRL links. This is correct, since generic arguments are not part of GRL, so they should also not occur in links.

We next define the attack link, which is the only link that RationalGRL adds to GRL. 

\begin{definition}[Attack Link]
\label{def:link:attack}
An attack link $att\in \mathbb{N}\times \mathbb{N}$ is a relation such that $att=(i,j)$ means:
\begin{itemize}
\item $i\in \mathbb{N}$ is the unique identifier of the element that is performing that attack,
\item $j\in \mathbb{N}$ is the unique identifier of the element that is being attacked.
\end{itemize}
Intuitively, $att=(i,j)$ means that element $i$ is attacking element $j$. A set of attack links is denoted by $Att$.
\end{definition}

Next we define an argument as either a generic argument or any of the GRL elements or links. This captures the specification in the RationalGRL metamodel (Fig.~\ref{fig:metamodel}) in which the class \textsf{Argument} is a superclass of \textsf{GenericArgument} and \textsf{GRLModelElement}, which again is a superclass of both \textsf{ElementLink} and \textsf{GRLLinkableElement}. A \textsf{GRLLinkableElement} is in turn a superclass of \textsf{Actor} and \textsf{IntentionalElement}. In sum, we define an argument simply as any one of the GRL elements or links, or a generic argument.

\begin{definition}[Argument]
\label{def:argument}
A set of arguments $Arg = IE\cup Act\cup R_{ActIE}\cup Contr\cup Decomp \cup Dep\cup GA$ consists of:
\begin{itemize}
\item a set of intentional elements $IE$ (Def.~\ref{def:ie}), 
\item a set of actors $Act$ (Def.~\ref{def:actor}),
\item a set of Actor-IE relations $R_{ActIE}$ (Def.~\ref{def:act-ie-relation}), 
\item a set of contribution links $Contr$ (Def.~\ref{def:link:contrib}), 
\item a set of decomposition links $Decomp$ (Def.~\ref{def:link:decomp}), 
\item a set of dependency links $Dep$ (Def.~\ref{def:link:dependency}), 
\item a set of a generic arguments $GA$ (Def.~\ref{def:generic-argument}).
\end{itemize}
\end{definition}

In order to identify arguments with the corresponding GRL element, we also add a relation between the element ids and the corresponding element. Recall the definition of $Element$ from Def.~\ref{def:set-definitions}.

\begin{definition}[Argument-Element mapping]
\label{def:arg-elem-mapping}
An \emph{argument-element mapping} $argElem\in \mathbb{N}\times Element$ is a mapping from an element identifier to its corresponding GRL element. So if $argElem=(i,elem)$, then
\begin{itemize}
\item $i\in\mathbb{N}$ is the identifier of the GRL element,
\item $elem\in Element$ (Def.~\ref{def:set-definitions}) is the GRL element type identified by $i$.
\end{itemize}
We denote a set of argument-element mappings with $ArgElem$.
\end{definition}

\begin{definition}[RationalGRL Model]
\label{def:rationalgrl-model}
A \emph{RationalGRL model} $RatGRL=(Arg, Att, ArgElem)$ consists of a set of arguments $Args$ (Def.~\ref{def:argument}), a set of attack links $Att$ (Def.~\ref{def:link:attack}), and an of argument-element mappings (Def.~\ref{def:arg-elem-mapping}).
\end{definition}

In order to compute when an argument is accepted and when not we use argumentation semantics.  We use the standard approach here, which is known as \emph{Dung's semantics}. The following notions are preliminary.

\begin{definition}[Argumentation Framework\~cite{}]
\label{def:argumentation-framework}
An \emph{argumentation framework} $AF=(Arg,Att)$ consists of a set of arguments $Arg$ and a set of attack relations $Att\subseteq Arg\times Arg.$
\end{definition}

We see that the definition of an argumentation framework is very close to that of a RationalGRL model. This allows us to use the following results directly.

\begin{definition}[Attack, conflict-freeness, defense, and admissibility~\cite{Dung1995}] Suppose an argumentation framework $AF=(Arg,Att)$, two sets of arguments $S\cup S'\subseteq Arg$, and some argument $A\in Arg$. We say that
\begin{itemize}
\item $S$ \emph{attacks} $A$ if some argument in $S$ attacks $A$,
\item $S$ \emph{attacks} $S'$ if some argument in $S$ attacks some argument in $S'$,
\item $S$ is \emph{conflict-free} if it does not attack itself,
\item $S$ \emph{defends} $A$ if for each $B$ such that $B$ attacks $A$, $S$ attacks $B$,
\item $S$ is \emph{admissible} if $S$ is conflict-free and defends each argument in it.
\end{itemize}
\end{definition}

\begin{figure}[ht!]
\centering
\begin{tikzpicture}
        \node[minimum size=1cm] (b) [argNodeIN] at (-2,0) {$A_1$};
        \node[minimum size=1cm] (c) [argNodeIN] at (0,0) {$A_2$};
        \node[minimum size=1cm] (d) [argNodeIN] at (2,0) {$A_3$};
             
         \path
    (c) edge [attackLink] (b)
    (d) edge [attackLink] (c);
    
\end{tikzpicture}
\caption{Example argumentation framework.}
\label{fig:goalmodeling:arg2}
\end{figure}

Let us explain these definitions using the example argumentation framework in Figure~\ref{fig:goalmodeling:arg2}, where $A_2$ attacks $A_1$ and $A_3$ attacks $A_2$. There are two admissible sets: $\{A_3\}$ and $\{A_1, A_3\}$, in which $A_3$ defends $A_1$ against its attacker $A_2$. Sets containing both $A_2$ and either $A_1$ or $A_3$ are not conflict free, and the sets $\{A_1\}$ and $\{A_2\}$ do not defend themselves against $A_2$ and $A_3$, respectively. 

Given the notion of admissible sets, we can then define our argumentation semantics. There are a large number of different semantics to determine which arguments are acceptable; in this article, we choose preferred semantics.

\todo{Marc}{Marc}{Say something about what we do with multiple extensions.}

\begin{definition}[Preferred semantics~\cite{Dung1995}] \label{def:semantics}
A preferred extension of a RationalGRL model $R$ is a maximal (w.r.t. set inclusion) admissible set of $R$.
\end{definition}

In our example from Figure~\ref{fig:goalmodeling:arg2}, there is one preferred extension, namely $\{A_1,A_3\}$.

\todo{Marc}{Marc}{Give example with concrete RationalGRL model}

\begin{algorithm}[h]
  \caption{RationalGRL to GRL Translation}\label{alg:translation}
  \begin{algorithmic}[1]
    \Procedure{$Translate$}{$RatGRL$}
    \State $E \leftarrow ComputeExtension(Arg,Att)$
    \State $IE\leftarrow\emptyset$, $Act\leftarrow\emptyset$, $R_{ActIE}\leftarrow\emptyset$, $Contr\leftarrow\emptyset$
    \State $Decomp\leftarrow\emptyset$, $Dep\leftarrow\emptyset$
    \For{$(A.id, T)\in ArgElem \mid A\in E$}
      \Switch{$T$}
          \Case{$T\in Type$}
            \State $IE\leftarrow IE\cup \{A\}$
          \EndCase
          \Case{$T = Actor$}
            \State $Act\leftarrow Act \cup\{A\}$
          \EndCase
          \Case{$T=Contr$}
            \State $Contr\leftarrow Contr\cup \{A\}$
          \EndCase
          \Case{$T=Dep$}
            \State $Dep\leftarrow Dep\cup \{A\}$
          \EndCase
          \Case{$T=Decomp$}
            \State $Decomp\leftarrow Decomp\cup\{A\}$
          \EndCase
      \EndSwitch
    \EndFor
    \State \Return $(IE,Act,R_{ActIE}, Contr, Decomp, Dep)$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

The previous definition of a preferred extension allows us to compute accepted arguments in a RationalGRL model. In the following definition we make precise the notion of a valid RationalGRL model.

\begin{definition}[Valid RationalGRL Model]
Suppose a RationalGRL model $RatGRL = (Arg, Att, ArgElem)$ with preferred extension $E=(A_1,\ldots,A_n)$. $RatGRL$ is a \emph{valid RationalGRL model} iff $Translate(RatGRL)$ (Alg.~\ref{alg:translation}) is a valid GRL model (Def.~\ref{def:valid-grl-model}).
\end{definition}

\todo{Marc}{Marc}{Explain conditions here and give some examples}

\subsection{Algorithms for argument schemes and critical questions}
\label{sect:algorithms}

In the previous section we formalized a \emph{static} representation of the RationalGRL framework. In this section we formalize the \emph{dynamics}. We do so by developing algorithms for applying argument schemes and critical questions in the context of a RationalGRL model (Def.~\ref{def:rationalgrl-model}). These algorithms produce new elements and attack relations. We can then use argumentation semantics (Def.~\ref{def:semantics}) to compute sets of accepted arguments. The content of these arguments is then used to compute the resulting RationalGRL model, together with enabled and disabled GRL elements and their underlying arguments.

\paragraph{Argument Schemes}

In all of the following algorithms, we assume the following
\begin{itemize}
\item There algorithms are being applied to some valid RationalGRL model $RGRL$,
\item The procedure $mindId()$ generates a new unique id.
\end{itemize}

The algorithms for applying argument schemes are short, and consist simply of adding an argument for the element that is being added.

\begin{algorithm}[h]
  \caption{AS0: Add a new actor with name $n$}\label{alg:as0}
  \begin{algorithmic}[1]
    \Procedure{$AS_0$}{$Arg, Att, n$}
    \State $actor \leftarrow (mintId(), n)$ 
    \State $Arg\leftarrow Arg \cup \{actor\}$\label{alg:as0:2}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsubsection{Algortihm~\ref{alg:as0} for argument scheme AS0}

\paragraph{Explanation} For all of the argument schemes and critical questions algorithms, we assume an underlying RationalGRL model as defined in Def.~\ref{def:rationalgrl-model}. This model is shown in the first two lines.

The algorithm takes one argument, namely the name of the actor $a$. On line~\ref{alg:as0:1} of the algorithm, a new (unique) id is minted. On line~\ref{alg:as0:2}, then a list containing a single tuple $(id,a)$ is added to the set of lists of actors $\overline{Act}$, meaning that a new actor with id $id$ and name $a$ is added to the RationalGRL model (Def.~\ref{def:element-list}). In Figure~\ref{fig:examples:relevant-actor2}, .. TODO

\begin{algorithm}[h]
  \caption{Applying AS1: Actor $a_{id}$ has resource $r_{id}$}\label{alg:as1}
  \begin{algorithmic}[1]
     \State $RationalGRL=(\overline{IE}, \overline{Act}, R_{ActIE}, \overline{Contr}, Decomp,$
    \State \qquad\qquad\qquad\qquad$Dep, Arg, Att, Label)$
    \Procedure{$AS_1$}{$a_{id}, r_{id}$}
    \State $R_{ActIE}\gets (a_{id}, r_{id}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\paragraph{Example} \todo{Marc}{Marc}{Clarify that the actor and resource exist already. If not, we should first execute Algorithm 2, and then Algorithm 3. No need to combine them}

\emph{Algorithm~\ref{alg:as1} for argument scheme AS1:} This argument scheme takes two arguments, the identifier $a_{id}$ of the actor and the resource name $n$. The algorithm is similar to the previous one, with the difference that the newly added argument contains the statement $has(a_{id},id)$ as well, meaning that the actor with id $a_{id}$ has element $id$ (which is a resource). As an example, let us formalize the argument corresponding to resource \emph{External library} of actor \emph{Traffic tycoon} in Figure~\ref{fig:transcripts:grl}. First, we assume some id is associated with the actor: $$\{actor(0),name(0,traffic\_tycoon)\}.$$ Then we can formalize the argument for the resource as follows: $$\{resource(1),name(1,external\_library),has(0,1)\}.$$

\paragraph{Proof of Correctness} In order to show that this algorithm is correct, we should show that the new RationalGRL model still satisfies all the conditions of Def.~\ref{def:grl-model}. This is clearly the case, since adding a single element does not invalidate any condition.

Argument scheme AS1 to AS4 are all very similar, in the sense that they all assert that some element belongs to an actor. Therefore, we only provide the algorithm for AS1 and we assume the reader can easily construct the remaining algorithms AS2-AS4.

\begin{algorithm}[h]
  \caption{Applying AS5: Goal $g_{id}$ decomposes into tasks $T_1,\ldots,T_n$}\label{alg:as5}
  \begin{algorithmic}[1]
    \Procedure{$AS_5$}{$g_{id}, \{T_1,\ldots,T_n\}, type$}
    \State $T_{id} = \emptyset$\label{alg:as5:1}
    \For{$T_i$ in $\{T_1,\ldots,T_n\}$}
      \If{$\exists_{A\in Args}\label{alg:as5:2} \{task(t_{id}),name(t_{id},T_i)\}\subseteq A$}
        \State $T_{id} \gets T_{id} \cup \{t_{id}\}$
      \Else\label{alg:as5:3}
        \State $id\gets id+1$
        \State $A \gets \{task(id),name(id,T_i)\}$
        \State $Args \gets Args\cup A$
        \State $T_{id} \gets T_{id} \cup \{id\}$
      \EndIf
    \EndFor
    \State $id\gets id+1$\label{alg:as5:4}
    \State $A\gets \{decomp(id, g_{id}, T_{id}, type)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\todo{Marc}{Marc}{This algorithm does not make much sense to me. We simply add a decomposition link, no need to make it so complicated. I actually think we can omit this algorithm.}

\subsubsection{Algorithm~\ref{alg:as5} for argument scheme AS5}

\paragraph{Explanation} \todo{Marc}{Marc}{I think we should remove all this stuff. In this part we are simply adding GRL elements, which is trivial. The interesting part are the critical questions}

The procedure in Algorithm~\ref{alg:as5} takes three arguments: $g_{id}$ is the identifier of goal $G$, $T=(T_1,\ldots,T_n)$ is a list of decomposing task names, and $type\in\{and,or,xor\}$ is the decomposition type. The difficulty of this algorithm is that each of the tasks are stated in natural language, and it is not directly clear whether these tasks are already in the GRL model or not. Therefore, we have to check for each tasks whether it already exists, and if not, we have to create a new task. On line~\ref{alg:as5:1}, the set $T_{id}$ is initialized, which will contain the ids of the tasks $T_1,\ldots,T_n$ to decompose into. In the for-loop, the if-statement on line~\ref{alg:as5:2} checks whether some argument already exists for the current task $T_i$, and if so, it simply adds the identifier of the task ($t_{id}$) to the set of task identifiers $T_{id}$.\footnote{Note that the existing task may be disabled, but this does not matter, since the decomposition relation will be suppressed for disabled elements.} Otherwise (line~\ref{alg:as5:3}), a new task is created and the new identifier $id$ is added to the set of task identifiers. After the for loop on line~\ref{alg:as5:4}, an argument for the decomposition link itself is constructed, and it is added to the set of arguments $Args$.

\paragraph{Example}
Let us explain this algorithm with the XOR-decomposition of goal \texttt{Generate cars} of Figure~\ref{fig:transcripts:grl}. Suppose the following arguments are constructed already:
\begin{itemize}
\item $\{goal(0),name(0,generate\_cars)\},$
\item $\{taks(1),name(1,keep\_same\_cars\}.$
\end{itemize}
Suppose furthermore that someone wants to put forward the argument that goal \texttt{Generate cars} XOR-decomposes into tasks \texttt{Keep same cars} and \texttt{Create news cars}. Formally: $AS_5(0,\{generate\_cars,keep\_same\_cars\},xor)$. The algorithm will first set $T_{id}=\emptyset$, and then iterate over the two task names. For the first task $generate\_cars$, there does not exist an argument $\{task(t_{id}),name(t_{id},generate\_cars)\}$ yet, so a  new argument is created. Suppose the following argument is created: $\{task(2),name(2,generate\_cars)\}.$ After this, 2 is added to $T_{id}$. For the second task an argument exists already, namely $\{task(1),name(1,keep\_same\_cars)\}$, so 1 is simply added to $T_{id}$. After the for loop, we have $T_{id}=\{1,2\}$. Next, the decomposition argument is created, which is $\{decomp(3,0,\{1,2\},xor)\}$. This argument is added to $Args$ and the algorithm terminates.

\begin{algorithm}[h]
  \caption{Applying AS6: Task $t_{id}$ contributes to softgoal $s$}\label{alg:as6}
  \begin{algorithmic}[1]
    \Procedure{$AS_6$}{$t_{id}, s$}
    \If{$\exists_{A\in Args} \{softgoal(i),name(i,s)\}\subseteq A$} \label{alg:as6:if}
        \State $s_{id} \gets i$
    \Else
      \State $id\gets id+1$
      \State $A \gets \{softgoal(id),name(id,t)\}$
      \State $Args \gets Args\cup A$
      \State $s_{id} \gets id$
    \EndIf
    \State $id\gets id+1$
    \State $A\gets \{contr(id, t_{id}, s_{id}, pos)\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\paragraph{Proof of Correctness}

\subsubsection{Algorithm~\ref{alg:as6} for argument scheme AS6} 

\todo{Marc}{Marc}{This one is also not interesting.. just add a contribution link}
\paragraph{Explanation} The procedure in Algorithm~\ref{alg:as6} takes two arguments: $t_{id}$ is the identifier of task $T$, and $s$ is the softgoal name that is contributed to. The idea behind this algorithm is very similar to the previous one, with the difference that in the current algorithm we create a single relation, while we created a set of relations in the previous algorithm. First, the if-statement on line~\ref{alg:as6:if} checks whether the softgoal exists already, and if not, an argument is added for it. This ensures that all softgoals have corresponding arguments. After the if-statement, the argument for the contribution link is created and it is added to the set of arguments $Args$. 

\paragraph{Example} Let us again illustrate this with a simple example from Figure~\ref{fig:transcripts:grl}. Suppose the following argument exists already: $\{task(0),name(0,keep\_same\_cars\}$, and suppose someone would like to add an argument that the task \texttt{Keep same cars} contributes positively to softgoal \texttt{Dynamic simulation}, i.e. $AS_6(0,dynamic\_simulation)$. The algorithm first checks whether an argument already exists for the softgoal, and when it finds out it does not exist, creates the argument $\{softgoal(1),name(1,dynamic\_simulation)\}$ and adds it to $Args$. Then, the argument for the contribution is added to $Args$ as well, which is $\{contr(2,0,1,pos)\}$.

\emph{Algorithms for argument schemes AS7-AS11:} The algorithms for $AS7$ to $AS11$ all have a very similar structure as Algorithm~\ref{alg:as6} and have therefore been omitted. Again, we assume the reader can reconstruct them straightforwardly.

\paragraph{Proof of correctness} 

\subsubsection*{Algorithms for critical questions}

We now develop algorithms for our critical questions. Recall that answering a critical question can have four effects, and we discuss each of these effects separately.

\begin{algorithm}[h]
  \caption{Applying DISABLE: Element $i$ is disabled}\label{alg:disable}
  \begin{algorithmic}[1]
    \Procedure{DISABLE}{$i$}
    \State $id\gets id+1$
    \State $A\gets \{disabled(i))\}$
    \State $Args \gets Args\cup A$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\todo{Marc}{Marc}{Here we would add an argument and an attack from the argument to the intentional element. We don't add ``disabled'' because this is what argumentation semantics should do for us.}

\emph{Algorithm~\ref{alg:disable} (\textsf{DISABLE}) for critical questions CQ0-CQ5a, CQ6a, CQ7a, CQ8, CQ11, and CQ12:} The disable operation consists of adding an argument stating the GRL element with identifier $i$ is disabled. Let us reconsider the example of Figure~\ref{fig:examples:relevant-actor}. This example consists of an instantiation of argument scheme AS0, which is attacked by an argument that resulted from answering critical question. The instantiation of AS0 leads to the argument $A=\{actor(0),name(0,dev\_team\}$. After applying $DISABLE(0)$ we obtain the arguments: $$Args=\{\{actor(0),name(0,dev\_team\}, \{disabled(0)\}\}.$$ Note that our implementation of this attack does not lead to an actual attack in the argumentation framework.

\begin{algorithm}[h]
  \caption{Answering CQ5b: ``Does goal $G$ decompose into any other tasks?'' With: ``Yes, namey into tasks $t_1,\ldots,t_k$''}\label{alg:cq5b}
  \begin{algorithmic}[1]
    \Procedure{CQ5b}{$g_{id},\{i_1,\ldots,i_n\}, type, \{t_1,\ldots,t_k\}$}
    \State $T_{id} = \{i_1,\ldots,i_n\}$
    \For{$t_i$ in $\{t_1,\ldots,t_k\}$}\label{alg:cq5b:for1}
      \If{$\exists_{A\in Args} \{task(t_{id}),name(t_{id},t_i)\}\subseteq A$}
        \State $T_{id} \gets T_{id} \cup \{t_{id}\}$
      \Else
        \State $id\gets id+1$
        \State $A \gets \{task(id),name(id,t_i)\}$
        \State $Args \gets Args\cup A$
        \State $T_{id} \gets T_{id} \cup \{id\}$
      \EndIf
    \EndFor
    \State $id\gets id+1$
    \State $A_{new} = \{decomp(id, g_{id}, T_{id}, type)\}$\label{alg:cq5b:newarg}
    \For{$A$ in $\{decomp(\_,g_{id},\_,\_)\}\subseteq A\mid A\in Args\}$}\label{alg:cq5b:for2}
      \State $Att\gets Att \cup \{(A_{new},A)\}$
    \EndFor
    \State $Args \gets Args \cup \{A_{new}\}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\emph{Algorithm~\ref{alg:cq5b} (\textsf{REPLACE}) for critical questions CQ5b:} This algorithm is executed when critical question CQ5b is answered, which is a critical question for argument scheme AS5. Therefore, it assumes an argument for a goal decomposition already exists of the following form (see Algorithm~\ref{alg:as5}): $$\{decomp(d, g_{id}, \{i_1,\ldots,i_n\},type).$$  The goal of the algorithm is to generate a new argument of the form $decomp(d, g_{id}, \{i_1,\ldots,i_5\}\cup \{j_1,\ldots,j_k\}, type)$, where $\{j_1,\ldots,j_k\}$ are the identifiers of the additional decomposing tasks $\{t_1,\ldots,t_k\}$.

The algorithm takes as input the goal identifier $g_{id}$, the set of existing decomposing task identifiers $i_1,\ldots,i_n$, the decomposition type, and the names of the new tasks $t_1,\ldots,t_k$ that should be added to the decomposition. The first part of the algorithm is familiar from Algorithm~\ref{alg:as5}: For each task name we check whether it already exists as an argument (line 4), and if it doesn't (line 6) we add a new argument for it. After the for-loop (line 13), a new argument is created for the new decomposition relation (14). After this, the for-loop on line 15 ensures that the new argument attacks all previous arguments for this decomposition (note that the variable ``$\_$'' means ``do not care''). Only at the very end the new argument is added (line 18), to ensure it does not attack itself after the for loop of line 15-17. 

An example of this algorithm is shown in Figure~\ref{fig:examples:cq5b}.\footnote{Note that part of the arguments (the statements about actors) have been omitted from the figure for readability.} Before the critical question is applied, the following arguments have been put forward:
\begin{itemize}
\item $\{goal(0),name(0,show\_simulation)\}$
\item $\{task(1),name(1,generate\_traffic)\}$
\item $\{task(2),name(2,compute\_lights)\}$
\item $\{decomp(3,0,\{1,2\},and)\}$.
\end{itemize}

Next, Algorithm~\ref{alg:cq5b} is called as follows: $CQ5b(0,\{1,2\},and,\{show\_controls\})$. That is, the existing decomposition is challenged by stating that goal $show\_simulation$ not only decomposes into $generate\_traffic$ and $compute\_lights$, but it also decomposes into $show\_controls$. Since this task does not exist yet, it is created by the algorithm, which also ensures the new argument for the decomposition link attacks the previous argument for the decomposition link.

\begin{figure*}[ht!]
\centering
        \begin{tikzpicture}
        \node (a0) [argNodeIN,minimum width=1.5cm] at (-5,0) {
        	\smallargtext{AS3}{$\{goal(0),$\\$name(0,show\_sim\}$}
        };
        \node (a1) [argNodeIN] at (0,0) {
        \smallargtext{AS2}{$\{task(1),$\\$name(1,gen\_traffic\}$}
        };
        \node (a2) [argNodeIN] at (5,0) {
        \smallargtext{AS2}{$\{task(3),$\\$name(2,show\_ctrls\}$}
        };
        \node (a2a) [argNodeIN] at (-2.5,-2) {
        \smallargtext{AS2}{$\{task(2),$\\$name(2,comp\_lights\}$}
        };
        \node (a3) [argNodeOUT] at (-3,-4) {$\{decomp(3,0,\{1,2\},and\}$
        };
        \node (a4) [argNodeIN] at (3,-4) {$\{decomp(3,0,\{1,2,3\},and\}$
        };
         
         \path
    (a4) edge [attackLink] (a3)
    (a3) edge [CQLink, bend right=50] node [below,draw=none] {CQ5b} (a4)
    (a4) edge [CQLink] node [left,draw=none] {CQ5b} (a2);
\end{tikzpicture}
\caption{Example of applying critical question CQ5b (Algorithm~\ref{alg:cq5b})}
\label{fig:examples:cq5b}
\end{figure*}

\emph{Algorithms for critical questions CQ10a and CQ10b (REPLACE)}: These algorithms have a very similar structure as Algorithm~\ref{alg:cq5b} and have therefore been omitted.

\begin{algorithm}[h]
  \caption{Answering CQ13: ``Is the name of element $i$ clear?'' With: ``No, it should be $n$''}\label{alg:cq13}
  \begin{algorithmic}[1]
    \Procedure{CQ13}{$i, n$}
    \State $ArgsN \gets\{ A\in Args \mid name(i,x)\in A\}$
    \State $B\gets B'\backslash \{name(i,\_)\}$ with $B'\in ArgsN$
    \State $A \gets B \cup \{name(i,n)\}$
    \State $Args \gets Args \cup \{A\}$
    \For{$C$ in $ArgsN$}
      \State $Att\gets Att \cup \{(A,C)\}$
    \EndFor
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\emph{Algorithms for critical question CQ13 (REPLACE):} This algorithm is used to clarify/change the name of an element. It takes two parameters: the element identifier $i$ and the new name $n$. The idea behind the algorithm is that we construct a new argument for $n$, and to ensure that this argument attacks all previous arguments for giving a name to this element. Here we can use the following fact: Suppose $Args$ is a set of arguments, each containing an atom about the name for an element $i$, i.e. for all $A\in Args: name(i,_)\in Args$, then all arguments in $Args$ are the same except for the $name$ atoms, i.e. for all $A,B\in Args: A\backslash\{name(i,_)\} = B\backslash\{name(i,_)\}$. This means that if we would like to attack every argument of $Args$ with a new argument that replaces the $name$ atom, we can simply take any argument in $Args$, remove the previous $name$ atom, add the new one and attack all arguments in $Args$. This is exactly what the algorithm does.


On line 2, all arguments that have been put forward for this element and contain $name(i,x)$ are collected into the set $ArgsN$. On line 3, some arguments $B'\in ArgsN$ minus the $name$ statement is assigned to $B$ (note that it does not matter which one we pick), and on line 4 $B$ is joined with the new $name$ statement and stored in $A$, which is then added to the set of arguments $Args$. The for-loop on lines 6-8 ensures all previous arguments for names of the element are attacked by the new argument.

\begin{figure}[ht!]
\centering
        \begin{tikzpicture}[->]
        \node (a0a) [argNodeIN] at (-2,2) {
        	\longargtext{AS0}{$\{actor(0),name(0,student)\}$}
        };
        \node (a0) [argNodeOUT] at (-2,0) {
        	\longargtext{AS2}{$\{task(1),name(1,create\_road),has(0,1)\}$}
        };
        \node (a1) [argNodeOUT] at (-2,-2) {
        	\longargtext{AS2}{$\{task(1),name(1,choose\_pattern),has(0,1)\}$}
        };
        \node (a2) [argNodeOUT] at (-2,-4) {
        	\longargtext{AS2}{$\{task(1),name(1,pattern\_pref),has(0,1)\}$}
        };
        \node (a3) [argNodeIN] at (-2,-6) {
        	\longargtext{AS2}{$\{task(1),name(1,road\_pattern),has(0,1)\}$}
        };
\begin{pgfonlayer}{background}
         \path
    (a1) edge[attackLink] (a0)
    (a2) edge[attackLink] (a1)
    (a2) edge[attackLink, bend right=20] (a0)
    (a3) edge[attackLink] (a2)
    (a3) edge[attackLink, bend right=20] (a1)
    (a3) edge[attackLink, bend right=40] (a0);
\end{pgfonlayer}

	\path
	(a0) edge [CQLink, bend right=50] node [left,draw=none] {CQ13} (a1)
    (a1) edge [CQLink, bend right=50] node [left,draw=none] {CQ13} (a2)
    (a2) edge [CQLink, bend right=50] node [left,draw=none] {CQ13} (a3);
\end{tikzpicture}
\caption{Applying critical question CQ13 (Algorithm~\ref{alg:cq13}) to the example in Figure~\ref{fig:examples:clarification}.}
\label{fig:examples:clarification:formal}
\end{figure} 

An example of of Algorithm~\ref{alg:cq13} is shown in Figure~\ref{fig:examples:clarification:formal}. Let us consider the last application of CQ13 (bottom argument). Before this application, the following arguments have been put forward:
\begin{itemize}
\item $A_1$: $\{actor(0),name(0,student)\}$
\item $A_2$:$\{task(1),name(1,create\_road),has(0,1)\}$
\item $A_3$ $\{task(1),name(1,choose\_pattern),has(0,1)\}$
\item $A_4$:$\{task(1),name(1,pattern\_pref),has(0,1)\}$
\end{itemize}
The algorithm is now called as follows: $CQ13(1,road\_pattern)$, i.e., the new name of the element should be $road\_pattern$. Let us briefly run through the algorithm. After executing line 2 we obtain $ArgsN=\{A_2,A_3,A_4\}$, since only those arguments contain $name(1,\_)$. Next, on line 3, $B=\{task(1),has(0,1)\}$, i.e., $B$ is the general argument for the task without the $name$ statement. After line 4 we have $$A=\{task(1),has(0,1),name(1,road\_pattern),$$ which is added to $Args$ and attacks arguments $A_2,A_3$, and $A_4$. 

\emph{Algorithms for critical questions CQ6b, CQ6c, CQ6d, CQ7b, and CQ9 (INTRO):} The introduction algorithms for the critical questions are all very similar to the INTRO algorithms for argument schemes (Algorithm~\ref{alg:as1}). They have therefore been omitted.

\begin{algorithm}[h]
  \caption{Generic counterargument to argument $A$}\label{alg:cq6b}
  \begin{algorithmic}[1]
    \Procedure{Attack}{$A$}
    \State $A_{new} = \{\}$
    \State $Args \gets Args \cup \{A_{new}\}$
    \State $Att \gets Att \cup \{(A_{new},A)\}$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\emph{Algorithm for $Att$ (Generic counter argument:} Applying a generic counter argument is very simple, and simply results on an attack on the original argument. We illustrate this by continuing our example from Figure~\ref{fig:examples:relevant-actor2:formal} (Algorithm~\ref{alg:as0}). The example is shown in Figure~\ref{fig:examples:relevant-actor2:formal}, where we see that a generic counter argument simply attacks the argument to disable the actor.

\begin{figure}[ht!]
\centering
        \begin{tikzpicture}
        \node (a0) [argNodeIN] at (-3.7,0) {
        	\smallargtext{AS0}{$\{actor(0),name(0,dev\_team\}$}
        } ;
        \node (a1) [argNodeOUT] at (-3.7,-2){
        	\argtext{DISABLE}{$\{disabled(0)\}$}
        };
        \node (a2) [argNodeIN] at (-3.7,-4){
        	\argtext{Att}{$\{\}$}
        };
         \path
    (a0) edge [CQLink, bend right=50] node [left,draw=none] {CQ0} (a1)
    (a1) edge [CQLink, bend right=50] node [left,draw=none] {Att} (a2)
    (a2) edge [attackLink] (a1);
\end{tikzpicture}
\caption{Formalization of the arguments in Figure~\ref{fig:examples:relevant-actor2}.}
\label{fig:examples:relevant-actor2:formal}
\end{figure}

\subsection{Constructing GRL models}
\label{sect:rationalGRL-GRL}
\todo{F}{F,M}{Dit is snel getypt, moet nog checken of het klopt.}

\begin{definition}[RationalGRL model] A RationalGRL model $\mathcal{R}$ is an argumentation framework $AF=(Args,Att)$ where all arguments in $Args$ and attacks in $Att$ are based on algorithm X-XX.  
\end{definition}

\begin{definition}[GRL model] A GRL model $\mathcal{M}$ based on a RationalGRL model $\mathcal{R}$ is the preferred extension of $\mathcal{R}$.  
\end{definition}
=======
\todo{F}{F,M}{It would be good to have a formal definition of how to construct models given an argumentation framework. If we define a model M at the start of this section, this should be fairly easy.}

Constructing GRL models from the arguments is extremely simple: We simply compute the extensions of the argumentation frameworks, and collect all atomic sentences in the accepted arguments. This forms out GRL model. Let us briefly do so for the examples of the previous subsection:
\begin{itemize}
\item
Figure~\ref{fig:examples:relevant-actor:formal}: Since there are no attacks between the arguments, all atomic sentences are accepted. This results in the following specification: 
\begin{quote}
\begin{verbatim}
actor(0).
name(0,dev_team).
disabled(0).
\end{verbatim}
\end{quote}
This again corresponds to the GRL model on the right-hand side of Figure~\ref{fig:examples:relevant-actor}.
\item
Figure~\ref{fig:examples:cq5b}: There is one rejected argument and five accepted ones. The resulting specification is:
\begin{quote}
\begin{verbatim}
goal(0). name(0,show_simulation).
task(1). name(1,generate_traffic).
task(2). name(2,compute_lights).
task(3). name(3,show_controls).
decomp(3,0,{1,2,3},and).
\end{verbatim}
\end{quote}
\item Figure~\ref{fig:examples:clarification:formal}: There are only two accepted arguments. The resulting specification is:
\begin{quote}
\begin{verbatim}
actor(0). name(0, student).
task(1).  name(1,road_pattern).
has(0,1).
\end{verbatim}
\end{quote}
This corresponds to the right-hand GRL model of Figure~\ref{fig:examples:clarification}.
\item Figure~\ref{fig:examples:relevant-actor2:formal}. There are two accepted arguments, but the \emph{generic counterargument} does not contain any formulas. Therefore the resulting specification is:
\begin{quote}
\begin{verbatim}
actor(0).
name(0,dev_team).
\end{verbatim}
\end{quote}
This corresponds to the right-hand GRL model of Figure~\ref{fig:examples:relevant-actor2}.
\end{itemize}